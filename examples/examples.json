[{"id":"1d6822e3b60ba374","type":"tab","label":"Sedona Node Building Tab","disabled":false,"info":"","env":[]},{"id":"9b82ed7adaa7b270","type":"group","z":"1d6822e3b60ba374","name":"Global Setpoint Example","style":{"label":true},"nodes":["3ecddaa4e0b81cf7","911158fc3a3e67f6"],"x":34,"y":19,"w":1152,"h":82,"info":"Sets a default global setpoint. Otherwise, the global setpoint is adjusted through the UI nodes."},{"id":"02b974e2a765d1cf","type":"group","z":"1d6822e3b60ba374","name":"Example of context for inputs. Use global or flow context to store for all use. Will only have last value set.","style":{"label":true},"nodes":["e66159e9db3a6eab","1d93510cbf22c5cf"],"x":34,"y":473,"w":1138,"h":134},{"id":"9919aad00a5a6828","type":"group","z":"1d6822e3b60ba374","name":"Example of context for inputs. Use global or flow context though unless you need custom polling? Polling outputs can be expensive, uses cache. Could be non-global","style":{"label":true},"nodes":["17473b9c78128e75","c4cf0eaec21ca0d6","35bcd70d74eaba5e","6e3859ec817ffb54","6f4cc923f739bf57","f6bd54f6d1fbf604","947a9f0a19d1b392","701fd7be3a582274"],"x":34,"y":779,"w":1132,"h":122},{"id":"56fdb4d21be1538e","type":"group","z":"1d6822e3b60ba374","name":"Example of context for inputs. Use global or flow context but provides for new immediate values","style":{"label":true},"nodes":["af3d0b4d0f88dec2","ac444f954059fb0e","42925516bf9ed0ad","f29296b63eea16d3","277630f222418f77","78a590c7297341ef","76e7d74ac7febb5e"],"x":34,"y":619,"w":1132,"h":122},{"id":"b6ff1d1d70ea795e","type":"group","z":"1d6822e3b60ba374","name":"Time Sequence Implementation","style":{"label":true},"nodes":["408bf47a4e15bf5e","33703438e0b4ad7e","c969c1bce8bc327b","bb50a79ad1278a40","35cb85789fdae36b","47d5f326953d211d","d7fac52daac0072c","fbe110868dbb4ad8"],"x":34,"y":144,"w":1132,"h":217},{"id":"ec9549b63c4af34f","type":"group","z":"1d6822e3b60ba374","name":"'And' Implementation","style":{"label":true},"nodes":["dad318b6dd9beac7","a711392670666c37","6d1a3de9a2c17e52","260314cf582bd887","6772c4b2cc7ef6ee","c387b08dccb22ae1","a6d3054166f3b036","4d6aa96272f6f0a7","a9a73830ef654c90","0c712c5e203fe346","e85d8f0467e08e16","0cd7bb4b8e306245","810cdb5fe25c7c7e"],"x":1254,"y":119,"w":772,"h":242},{"id":"02978c70d9a48d66","type":"group","z":"1d6822e3b60ba374","name":"Statistics","style":{"label":true},"nodes":["5a180f2f8b1b34ab","b323d3485bbba13c","317bdea43629ed5e","5a9c3371a6156f9b","3ed228585d61bff4","a2ae079529ab6a2e"],"x":2294,"y":39,"w":532,"h":242},{"id":"59013327c751cd0f","type":"group","z":"1d6822e3b60ba374","name":"Math","style":{"label":true},"nodes":["f63f6484acd02312","db37abdaef59734d","f3302be055fe08db","4227ba7b6b2b525b","8de672f8c66c6a0f","d789deaab98c681e","e73fbc28f443845a","b9cbdebfb83c5e4b","4206724b5f1dcf3e","892c9e4dd092b13e","6998ab79fb3e949d","0333dc50b1d77108","dba522afa5d80237","01fd6587c9f33892","df161a565dfda2c7","f53652ab08a99953","927b0539b644e3e7","4b460e51fa20f61c","c5230994b10ae692","72e363ad9893b593","5eb0fb0078391fe1"],"x":2294,"y":299,"w":992,"h":562},{"id":"08570307a3388294","type":"group","z":"1d6822e3b60ba374","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["667e13fa6fbd88a4","672b7c30e77da6a6","61f4ddf31b9548d9","4048fdc688a79374"],"x":1254,"y":379,"w":592,"h":142},{"id":"17021ab187712cc3","type":"group","z":"1d6822e3b60ba374","name":"Testing","style":{"label":true},"nodes":["6f8d8280c2b877e1","703a9a1e9e8fad43","acd036852cf5dcb2","d593f1e616d95e3a","1c4a0c6ac11182fb","01dd5a0291ee34bf","4fd0b55f30005e8c","5b8d3cb044d997fe","1f23ada6b13f037b","e78c5e13c2b2acbd","6a62f8e0fe1fad2a","1f5fbfa83de44f17"],"x":2294,"y":879,"w":852,"h":322},{"id":"18db10675ce5c323","type":"group","z":"1d6822e3b60ba374","name":"Logic","style":{"label":true},"nodes":["e955ed10ed02fe4d","239a068ef3d5218f","302ebae443b08436","1872f6ae789c94e3","c982d77c48ea3f7a","57a1e99b38d1339d","727da4e3e54228da","12814af20e1fb45a","d0a59a9da07466bc","585a2a5143cdc7f4","3bd2b1028a03c3a0","7c30b7519b322ccf","047e0cba096016cf","05914194efba4838","3bbce6c5a475c58f","b49fd5c481848e2d","fedae56fa515c26b","c3e8143a97a15e6c","41d5f95b9654733a","88a6bf234551bdb8","434f10270db2ac1e","106b4dbbf5f7e8f2","f198ab0461517005","2dfde4e5298188b8","dbe25112bf321e73","0520e98abca50ad5","4585b59e227a62f7","6dd8aaf5258dce71","99c1ee797a7b9041","1aa1f0bfecc5bee9","25134203b1cab712","be95a707eba61951","6eb5af6978226b9a","0999e4ec2194ecab"],"x":34,"y":931.5,"w":992,"h":824.5},{"id":"5f70baf7384cf6e3","type":"group","z":"1d6822e3b60ba374","name":"'Compare' Implementation","style":{"label":true},"nodes":["e00f0bddbbe2d81d","b3160a2542fdf2ab","cc0268e860b78df5","b8aa1d6417dcf221","4ab42ce8fe612377","25fa803e81f75335"],"x":1254,"y":551.5,"w":592,"h":229.5},{"id":"9df534ffc2085145","type":"group","z":"1d6822e3b60ba374","name":"Needed: Tstat, Freq, LP, Linearize, Min, Max, Limiter,","style":{"label":true},"nodes":["30b202a2583316d8","e49aec2f4e76487a","f0fcdaf9afb2594f","b6fea3faddbde77d","cfc301742950d6ee"],"x":1254,"y":819,"w":892,"h":242},{"id":"f19a608dd6e58fd2","type":"group","z":"1d6822e3b60ba374","name":"Max Implementation","style":{"label":true},"nodes":["6ae6562bf83d8b7f","943a00f3adf7e893","ed450bbe96f08cf4","12340aea52d767cb","27cf3190d7fc2d97"],"x":1254,"y":1119,"w":572,"h":142},{"id":"5360543001f5b360","type":"group","z":"1d6822e3b60ba374","name":"Min Implementation","style":{"label":true},"nodes":["7150b086e9c0fc1c","db56798dfc406b65","817b0cca8243cb51","134508812af2d793"],"x":1254,"y":1359,"w":572,"h":142},{"id":"f2f049190ff39eb1","type":"group","z":"1d6822e3b60ba374","name":"Linearize Implementation - Usage: sensor value table","style":{"label":true},"nodes":["e31a4fe9ee481443","099ac74de27cb650","158de9a6957ad5d0","1dd0d7953417b881","4fc22d124d27b12c"],"x":1254,"y":1539,"w":622,"h":142},{"id":"b5acac16791836bb","type":"group","z":"1d6822e3b60ba374","name":"Min Implementation","style":{"label":true},"nodes":["6a846461605aad4d","cdf88b5420cc0fbd","8887bd675ef9b7bd","cbd77dbeb3caa24f"],"x":2294,"y":1239,"w":572,"h":142},{"id":"229300b1beb9bf03","type":"group","z":"1d6822e3b60ba374","name":"Frequency Implementation","style":{"label":true},"nodes":["16f1421947a4ec0d","379a50304242e0da","c9b756f9902d023c","60b33f32a00511a0"],"x":1254,"y":1719,"w":612,"h":182},{"id":"463764c52c5452a5","type":"group","z":"1d6822e3b60ba374","name":"Tstat: Hysteresis with mode selection","style":{"label":true},"nodes":["51b333a737aa829f","2f4f2c1e3aabe1e3","cd727ef12158e609","e3fab73e381919f3","da208ed24d52cb6f"],"x":3274,"y":871.5,"w":472,"h":209.5},{"id":"d813951177ea64b4","type":"group","z":"1d6822e3b60ba374","name":"Priority Implementation","style":{"label":true},"nodes":["120dc0af132f1834","888d83c237abd444","df38c5b580499864","3648d6b8fc71f825","116c5cd679953fd8","8c2543823b9cc919","318026f4d66ff01c","112db50e2ccfd6c9","21a92097619da35f","a888cdaba015827d","b42ce734819d724b","1cf9b5547b3ae10b","3aea1f7badde5a56"],"x":2294,"y":1399,"w":572,"h":282},{"id":"f7b552973c41a951","type":"group","z":"1d6822e3b60ba374","name":"Make a RateLimit node, only change by a rate, a node that only changes upon threshold change, only update after threshold","style":{"label":true},"nodes":["8a028827775b1b0f","d6417864dc594bc1","507929b42eb201a6","c2ea92f0354786d1","5b318b04ef936f99","3724cc8f4302c7b4","3e8c0628150d4577","d0c26d8f043578bc","c8a2476a10151b51","f2cdc9371de5dad5","1e7ba71ca9266a50","40e072d63d30ce24","7b5532729247a802","9d9320bf3cf1ea53"],"x":2274,"y":1759,"w":912,"h":349.5},{"id":"1d93510cbf22c5cf","type":"group","z":"1d6822e3b60ba374","g":"02b974e2a765d1cf","name":"Follow path structure","style":{"stroke":"#ffC000","label":true},"nodes":["05dc7e6e1e7600f1"],"x":874,"y":499,"w":272,"h":82},{"id":"c9ce10db918f0a6f","type":"group","z":"1d6822e3b60ba374","g":"7b8f944ba29665a5","name":"History Processor","style":{"stroke":"#a8a095","fill":"none","fill-opacity":"1","label":true,"color":"#afa89d"},"nodes":["45e2c09ca75f8289","968e30ac24b16b23","4b5896ae5ffa8151","519872a6db742acf","4fcb69110dc93052"],"x":3714,"y":1399,"w":592,"h":122},{"id":"be0e12cf52a203c2","type":"group","z":"1d6822e3b60ba374","g":"7b8f944ba29665a5","name":"Collect History","style":{"label":true},"nodes":["f39cc230dd2a699e","f19276a4be8aee8f","5b83de0d0bdb16a5"],"x":3194,"y":1439,"w":482,"h":82},{"id":"7b8f944ba29665a5","type":"group","z":"1d6822e3b60ba374","name":"History Collector","style":{"label":true},"nodes":["c9ce10db918f0a6f","be0e12cf52a203c2"],"x":3168,"y":1373,"w":1164,"h":174},{"id":"f58b0cf9d29bd7fb","type":"group","z":"1d6822e3b60ba374","name":"Network","style":{"label":true},"nodes":["70cd8faca5d123a0","eb3afd2a7fb103f7"],"x":3248,"y":1713,"w":1524,"h":514},{"id":"70cd8faca5d123a0","type":"group","z":"1d6822e3b60ba374","g":"f58b0cf9d29bd7fb","name":"WebSocket Connection","style":{"label":true},"nodes":["e13981b2f0ddd358","baa3602f64e53454","29a28768408478bc","dbbadd3e06f9f155","e31ac485f06364d7","a59c711e960f436a","7d2dae95cd8ab3ce","9292e07ea8f4a75b"],"x":3274,"y":1739,"w":1472,"h":322},{"id":"eb3afd2a7fb103f7","type":"group","z":"1d6822e3b60ba374","g":"f58b0cf9d29bd7fb","name":"Simulate point creation/registration","style":{"label":true},"nodes":["332af5ef12bc5960","b78f816ea9e452b7","6e1f9bd8fbbfe06c","488b183e9506554d"],"x":3304,"y":2119,"w":912,"h":82},{"id":"3ecddaa4e0b81cf7","type":"inject","z":"1d6822e3b60ba374","g":"9b82ed7adaa7b270","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"70","payloadType":"num","x":130,"y":60,"wires":[["911158fc3a3e67f6"]]},{"id":"911158fc3a3e67f6","type":"change","z":"1d6822e3b60ba374","g":"9b82ed7adaa7b270","name":"setpoint/room/heat","rules":[{"t":"set","p":"setpoint/room/heat","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1070,"y":60,"wires":[[]]},{"id":"dad318b6dd9beac7","type":"change","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"Contextual In1","rules":[{"t":"set","p":"context","pt":"msg","to":"in1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1540,"y":200,"wires":[["e85d8f0467e08e16","810cdb5fe25c7c7e"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"a711392670666c37","type":"inject","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"false","payloadType":"bool","x":1350,"y":320,"wires":[["a6d3054166f3b036"]]},{"id":"6d1a3de9a2c17e52","type":"inject","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":1350,"y":200,"wires":[["6772c4b2cc7ef6ee","a6d3054166f3b036","dad318b6dd9beac7","c387b08dccb22ae1"]]},{"id":"260314cf582bd887","type":"function","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"And","func":"// Initialize state from context, with defaults\nlet slots = context.get(\"slots\") ?? 2;\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(false);\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"slots\":\n            let slotValue = Number(msg.payload);\n            if (!isNaN(slotValue) && Number.isInteger(slotValue) && slotValue >= 2) {\n                slots = slotValue;\n                // Resize inputs array, preserving existing values where possible\n                let newInputs = Array(slots).fill(false);\n                for (let i = 0; i < Math.min(inputs.length, slots); i++) {\n                    newInputs[i] = inputs[i];\n                }\n                inputs = newInputs;\n                context.set(\"slots\", slots);\n                context.set(\"inputs\", inputs);\n                node.status({ fill: \"green\", shape: \"dot\", text: `slots set to ${slots}` });\n            } else {\n                node.warn(`Invalid slots value: ${msg.payload} (must be a positive integer greater than 2)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            break;\n        default:\n            // Check for dynamic input context (in1, in2, etc.)\n            if (msg.context.startsWith(\"in\")) {\n                let index = parseInt(msg.context.slice(2), 10);\n                if (!isNaN(index) && index >= 1 && index <= slots) {\n                    let value = Boolean(msg.payload); // Convert to boolean\n                    inputs[index - 1] = value; // Map 1-based to 0-based\n                    context.set(\"inputs\", inputs);\n                    node.status({\n                        fill: \"green\",\n                        shape: \"dot\",\n                        text: `in${index} set to ${value}`\n                    });\n                } else {\n                    node.warn(`Invalid input index: ${msg.context} (valid: in1 to in${slots})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: `invalid input index ${index}` });\n                    return null;\n                }\n            } else {\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n            break;\n    }\n}\n\n// Process input (non-config message assumed to update last input)\nlet value = Boolean(msg.payload); // Convert to boolean\nif (inputs.length > 0) {\n    inputs[inputs.length - 1] = value; // Update last input\n    context.set(\"inputs\", inputs);\n}\n\n// Compute logical AND\nlet newMsg = { payload: inputs.every(input => input === true) };\n\n// Set status\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${newMsg.payload}, in: [${inputs.join(\", \")}]`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"// Retrieve the stored values from the node context, or default to false if they don't exist\ncontext.set('in1', context.get('in1') || false);\ncontext.set('in2', context.get('in2') || false);","finalize":"","libs":[],"x":1750,"y":160,"wires":[[]],"inputLabels":["inputs"],"outputLabels":["result"],"icon":"font-awesome/fa-wrench","info":"Evaluates a configurable number of boolean inputs asynchronously, outputting true if all are true.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"slots\" for input count, \"inX\" for input X, e.g., \"in1\").  \r\n: payload (any) : Input value (boolean-convertible for \"inX\", number/string for \"slots\").  \r\n\r\n### Outputs\r\n: payload (boolean) : True if all inputs are true, false otherwise. (a new message is output)\r\n\r\n### Details\r\nThe AND Block is a Sedona-inspired node for control systems, processing inputs (`in1`, `in2`, ..., `inN`) stored in context. \r\n\r\nIt computes a logical AND, outputting `true` only when all inputs are `true`. \r\n\r\nInputs update asynchronously via `msg.context = \"inX\"` (e.g., `msg.context = \"in1\", msg.payload = true`) or non-config messages (updates last input, `in${slots}`). Use `msg.context = \"slots\"` to set the input count (integer ≥2, e.g., `msg.payload = 4` for `in1` to `in4`; default: 2).\r\n\r\n`msg.payload` for inputs is converted to boolean (e.g., `1`, `\"true\"` → `true`; `0`, `null` → `false`). For `slots`, it must be a number or string (e.g., `4`, `\"4\"`). Outputs are new messages (`{ payload: boolean }`), sent for every valid update, discarding input properties like `msg.context`.\r\n\r\nUse with a Contextual In node to set `msg.context`. Ideal for interlocking logic or asynchronous conditions in automation workflows.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid `slots` (non-integer, less than 2, e.g., `\"abc\"`, `1`): Shows \"invalid slots\" (red), no output.  \r\n- Invalid `inX` (e.g., `in5` for 4 slots): Shows \"invalid input index X\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus shows green for config (e.g., `in1 set to true`), blue for output (e.g., `out: ${result}, in: [true, true]`), red/yellow for errors.\r\n"},{"id":"4d6aa96272f6f0a7","type":"function","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"Or","func":"// Initialize state from context, with defaults\nlet slots = context.get(\"slots\") ?? 2;\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(false);\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"slots\":\n            let slotValue = Number(msg.payload);\n            if (!isNaN(slotValue) && Number.isInteger(slotValue) && slotValue > 0) {\n                slots = slotValue;\n                // Resize inputs array, preserving existing values where possible\n                let newInputs = Array(slots).fill(false);\n                for (let i = 0; i < Math.min(inputs.length, slots); i++) {\n                    newInputs[i] = inputs[i];\n                }\n                inputs = newInputs;\n                context.set(\"slots\", slots);\n                context.set(\"inputs\", inputs);\n                node.status({ fill: \"green\", shape: \"dot\", text: `slots set to ${slots}` });\n            } else {\n                node.warn(`Invalid slots value: ${msg.payload} (must be a positive integer)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            break;\n        default:\n            // Check for dynamic input context (in1, in2, etc.)\n            if (msg.context.startsWith(\"in\")) {\n                let index = parseInt(msg.context.slice(2), 10);\n                if (!isNaN(index) && index >= 1 && index <= slots) {\n                    let value = Boolean(msg.payload); // Convert to boolean\n                    inputs[index - 1] = value; // Map 1-based to 0-based\n                    context.set(\"inputs\", inputs);\n                    node.status({\n                        fill: \"green\",\n                        shape: \"dot\",\n                        text: `in${index} set to ${value}`\n                    });\n                } else {\n                    node.warn(`Invalid input index: ${msg.context} (valid: in1 to in${slots})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: `invalid input index ${index}` });\n                    return null;\n                }\n            } else {\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n            break;\n    }\n}\n\n// Process input (non-config message assumed to update last input)\nlet value = Boolean(msg.payload); // Convert to boolean\nif (inputs.length > 0) {\n    inputs[inputs.length - 1] = value; // Update last input\n    context.set(\"inputs\", inputs);\n}\n\n// Compute logical OR\nlet newMsg = { payload: inputs.some(input => input === true) };\n\n// Set status\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${newMsg.payload}, in: [${inputs.join(\", \")}]`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"// Retrieve the stored values from the node context, or default to false if they don't exist\ncontext.set('in1', context.get('in1') || false);\ncontext.set('in2', context.get('in2') || false);\ncontext.set('in3', context.get('in3') || false);\ncontext.set('in4', context.get('in4') || false);","finalize":"","libs":[],"x":1750,"y":200,"wires":[[]],"inputLabels":["inputs"],"outputLabels":["result"],"icon":"font-awesome/fa-wrench","info":"Evaluates a configurable number of boolean inputs asynchronously, outputting true if any are true.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"slots\" for input count, \"inX\" for input X, e.g., \"in1\").  \r\n: payload (any) : Input value (boolean-convertible for \"inX\", number/string for \"slots\").  \r\n\r\n### Outputs\r\n: payload (boolean) : True if any input is true, false otherwise. (a new message is output)\r\n\r\n### Details\r\nThe OR Block is a Sedona-inspired node for control systems, processing inputs (`in1`, `in2`, ..., `inN`) stored in context. \r\n\r\nIt computes a logical OR, outputting `true` if any input is `true`. \r\n\r\nInputs update asynchronously via `msg.context = \"inX\"` (e.g., `msg.context = \"in1\", msg.payload = true`) or non-config messages (updates last input, `in${slots}`). Use `msg.context = \"slots\"` to set the input count (integer ≥2, e.g., `msg.payload = 4` for `in1` to `in4`; default: 2).\r\n\r\n`msg.payload` for inputs is converted to boolean (e.g., `1`, `\"true\"` → `true`; `0`, `null` → `false`). For `slots`, it must be a number or string (e.g., `4`, `\"4\"`). Outputs are new messages (`{ payload: boolean }`), sent for every valid update, discarding input properties like `msg.context`.\r\n\r\nUse with a Contextual In node to set `msg.context`. Ideal for condition aggregation or asynchronous triggers in automation workflows.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid `slots` (non-integer, less than 2, e.g., `\"abc\"`, `1`): Shows \"invalid slots\" (red), no output.  \r\n- Invalid `inX` (e.g., `in5` for 4 slots): Shows \"invalid input index\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus shows green for config (e.g., `in1 set to true`), blue for output (e.g., `out: ${result}, in: [true, false]`), red/yellow for errors."},{"id":"f63f6484acd02312","type":"function","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Average","func":"// Initialize state from context, with defaults\nlet sum = context.get(\"sum\") ?? 0;\nlet count = context.get(\"count\") ?? 0;\nlet maxValues = context.get(\"maxValues\") ?? 10; // Default rolling window size\n\n// Define valid range\nconst minValid = 1;   // Ignore 0 or negative values\nconst maxValid = 150; // Upper limit\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"reset\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload} (must be boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                sum = 0;\n                count = 0;\n                context.set(\"sum\", sum);\n                context.set(\"count\", count);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n            }\n            return null;\n        case \"sampleSize\":\n            let newMaxValues = Number(msg.payload);\n            if (isNaN(newMaxValues) || !Number.isInteger(newMaxValues) || newMaxValues < 1) {\n                node.warn(`Invalid window size: ${msg.payload} (must be a positive integer)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid window size\" });\n                return null;\n            }\n            maxValues = newMaxValues;\n            context.set(\"maxValues\", maxValues);\n            node.status({ fill: \"green\", shape: \"dot\", text: `window set: ${maxValues}` });\n            return null;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// Process input\nif (msg.payload === undefined) {\n    node.warn(\"Invalid input: msg.payload is undefined\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\nlet newValue = Number(msg.payload);\nif (isNaN(newValue) || newValue < minValid || newValue > maxValid) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number between ${minValid} and ${maxValid})`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Update sum and count\nsum += newValue;\ncount++;\n\n// If we exceed the rolling window, adjust sum/count\nif (count > maxValues) {\n    let avg = sum / count;\n    sum -= avg; // Subtract rolling average\n    count--;    // Keep count within limits\n}\n\n// Store updated values\ncontext.set(\"sum\", sum);\ncontext.set(\"count\", count);\n\n// Calculate and return new rolling average\nconst avg = count ? sum / count : null;\nmsg.payload = avg;\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${avg !== null ? avg : \"null\"}`\n});\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2820,"y":340,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"<script type=\"text/markdown\" data-help-name=\"average-block\">\r\nComputes a rolling average of numeric inputs.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear state, \"sampleSize\" to set rolling window size).  \r\n: payload (number | boolean) : Number for averaging, boolean for reset, or number for window size.\r\n\r\n### Outputs\r\n: payload (number | null) : Current rolling average, or null if no valid inputs.\r\n\r\n### Details\r\nThe Average Block is a Sedona-inspired node for control systems, computing a rolling average of numeric `msg.payload` \r\nvalues within a valid range (1 to 150). It accumulates valid values in a configurable window \r\n(default 10 values), outputs the average as `msg.payload`, or null if no valid inputs. \r\nReset the state via `msg.context = \"reset\"` with `msg.payload = true`, clearing sum and count. \r\nSet the rolling window size via `msg.context = \"sampleSize\"` with `msg.payload` as a positive \r\ninteger (e.g., 5).\r\n\r\nThe input message is modified (`msg.payload` set to average) and output, preserving other \r\nproperties (e.g., `msg.topic`). Invalid inputs or config values are rejected with warnings. \r\nUse in automation workflows to monitor averaged sensor data, such as temperature or flow rates.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, or outside 1 to 150, e.g., `\"abc\"`, `0`, `151`): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid reset\" (red), no output.  \r\n- Invalid window size (non-integer, negative, or zero, e.g., `\"5\"`, `-1`, `0`): Shows \"invalid window size\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `state reset`, `window set: 5`), blue for output (e.g., `out: 12.345` or `out: null`), red for errors.\r\n</script>"},{"id":"6772c4b2cc7ef6ee","type":"change","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"Contextual In2","rules":[{"t":"set","p":"context","pt":"msg","to":"in2","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1540,"y":240,"wires":[["e85d8f0467e08e16","810cdb5fe25c7c7e"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"c387b08dccb22ae1","type":"change","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"Contextual In3","rules":[{"t":"set","p":"context","pt":"msg","to":"in3","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1540,"y":280,"wires":[["e85d8f0467e08e16","810cdb5fe25c7c7e"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"a6d3054166f3b036","type":"change","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"Contextual In4","rules":[{"t":"set","p":"context","pt":"msg","to":"in4","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1540,"y":320,"wires":[["e85d8f0467e08e16","810cdb5fe25c7c7e"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"e66159e9db3a6eab","type":"inject","z":"1d6822e3b60ba374","g":"02b974e2a765d1cf","name":"Update Rate","props":[{"p":"topic","vt":"str"}],"repeat":"1","crontab":"","once":true,"onceDelay":0.1,"topic":"update","x":160,"y":540,"wires":[[]]},{"id":"05dc7e6e1e7600f1","type":"change","z":"1d6822e3b60ba374","g":"1d93510cbf22c5cf","name":"global/sensors/room/temp","rules":[{"t":"set","p":"sensors/room/temp","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1010,"y":540,"wires":[[]]},{"id":"17473b9c78128e75","type":"link in","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"RoomTemperature_IN","links":[],"x":155,"y":820,"wires":[["6e3859ec817ffb54"]]},{"id":"c4cf0eaec21ca0d6","type":"link out","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"RoomTemperature_OUT","mode":"return","links":[],"x":815,"y":820,"wires":[]},{"id":"35bcd70d74eaba5e","type":"function","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"Cache","func":"// Initialize state\nlet lastValue = context.get(\"lastValue\") ?? null;\n\n// Handle configuration and input\nif (!msg.context) {\n    node.warn(\"Invalid input: msg.context missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\n    return null;\n}\n\nif (!msg.hasOwnProperty(\"payload\")) {\n    node.warn(`Invalid input: msg.payload missing for ${msg.context}`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n    return null;\n}\n\nswitch (msg.context) {\n    case \"update\":\n        lastValue = msg.payload;\n        context.set(\"lastValue\", lastValue);\n        node.status({ fill: \"blue\", shape: \"ring\", text: `in: update=${msg.payload}` });\n        return null;\n    case \"execute\":\n        msg.payload = lastValue;\n        node.status({ fill: \"blue\", shape: \"dot\", text: `out: ${msg.payload}, in: execute=${msg.payload}` });\n        return msg;\n    case \"reset\":\n        if (typeof msg.payload !== \"boolean\" || !msg.payload) {\n            node.warn(`Invalid reset value: ${msg.payload} (must be true)`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n            return null;\n        }\n        lastValue = null;\n        context.set(\"lastValue\", lastValue);\n        node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n        return null;\n    default:\n        node.warn(`Unrecognized context: ${msg.context}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n        return null;\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":690,"y":820,"wires":[["c4cf0eaec21ca0d6"]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Caches a value and outputs it on request.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear value) or action (\"update\" to store, \"execute\" to output).  \r\n: payload (any | boolean) : Value to store or output, boolean for reset.\r\n\r\n### Outputs\r\n: 1 (any) : Last stored value on execute.\r\n\r\n### Details\r\nStores `msg.payload` when `msg.context = \"update\"`, outputs the last stored value when `msg.context = \"execute\"`. Clear the stored value via `msg.context = \"reset\"` with `msg.payload = true`. Invalid inputs or config are rejected. Use to hold and retrieve values in automation workflows.\r\n\r\n### Error Handling\r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid reset value (non-boolean, not true): Shows \"invalid reset\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus: green for config (e.g., `state reset`), blue for input (e.g., `in: update=5`) and output (e.g., `out: 5, in: execute=5`), red for errors."},{"id":"6e3859ec817ffb54","type":"change","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"Contextual Execute","rules":[{"t":"set","p":"context","pt":"msg","to":"execute","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":510,"y":820,"wires":[["35bcd70d74eaba5e"]]},{"id":"6f4cc923f739bf57","type":"inject","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"Update Rate","props":[{"p":"topic","vt":"str"}],"repeat":"1","crontab":"","once":true,"onceDelay":0.1,"topic":"update","x":160,"y":860,"wires":[[]]},{"id":"f6bd54f6d1fbf604","type":"change","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"Contextual Update","rules":[{"t":"set","p":"context","pt":"msg","to":"update","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":510,"y":860,"wires":[["35bcd70d74eaba5e","947a9f0a19d1b392"]]},{"id":"947a9f0a19d1b392","type":"change","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"global/sensors/room/temp","rules":[{"t":"set","p":"sensors/room/temp","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1030,"y":860,"wires":[[]]},{"id":"76e7d74ac7febb5e","type":"switch","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"Switch","property":"context","propertyType":"msg","rules":[{"t":"eq","v":"execute","vt":"str"},{"t":"neq","v":"execute","vt":"str"}],"checkall":"true","repair":false,"outputs":2,"x":470,"y":700,"wires":[["ac444f954059fb0e"],["277630f222418f77"]]},{"id":"af3d0b4d0f88dec2","type":"link in","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"RoomTemperature_IN","links":[],"x":155,"y":660,"wires":[["42925516bf9ed0ad"]]},{"id":"ac444f954059fb0e","type":"link out","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"RoomTemperature_OUT","mode":"return","links":[],"x":575,"y":660,"wires":[]},{"id":"42925516bf9ed0ad","type":"change","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"Contextual Execute","rules":[{"t":"set","p":"context","pt":"msg","to":"execute","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":660,"wires":[[]]},{"id":"f29296b63eea16d3","type":"inject","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"Update Rate","props":[{"p":"topic","vt":"str"}],"repeat":"1","crontab":"","once":true,"onceDelay":0.1,"topic":"update","x":160,"y":700,"wires":[[]]},{"id":"277630f222418f77","type":"change","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"Contextual Update","rules":[{"t":"set","p":"context","pt":"msg","to":"update","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":650,"y":700,"wires":[["78a590c7297341ef"]]},{"id":"78a590c7297341ef","type":"change","z":"1d6822e3b60ba374","g":"56fdb4d21be1538e","name":"global/sensors/room/temp","rules":[{"t":"set","p":"sensors/room/temp","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1030,"y":700,"wires":[[]]},{"id":"5a180f2f8b1b34ab","type":"inject","z":"1d6822e3b60ba374","g":"02978c70d9a48d66","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":2390,"y":100,"wires":[["5a9c3371a6156f9b","317bdea43629ed5e","3ed228585d61bff4","a2ae079529ab6a2e","afc31c9c894ed311"]]},{"id":"b323d3485bbba13c","type":"inject","z":"1d6822e3b60ba374","g":"02978c70d9a48d66","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"false","payloadType":"bool","x":2390,"y":180,"wires":[["317bdea43629ed5e","3ed228585d61bff4","a2ae079529ab6a2e","5a9c3371a6156f9b","afc31c9c894ed311"]]},{"id":"317bdea43629ed5e","type":"function","z":"1d6822e3b60ba374","g":"02978c70d9a48d66","name":"Count","func":"// Initialize state from context, with defaults\nlet count = context.get(\"count\") ?? 0;\nlet prevState = context.get(\"prevState\") ?? false;\n\n// Get global formatNumber function\nconst formatNumber = global.get(\"utils.formatNumber\") || ((num) => num.toString());\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    switch (msg.context) {\n        case \"reset\":\n            if (!msg.hasOwnProperty(\"payload\")) {\n                node.warn(\"Configuration update ignored: msg.payload missing\");\n                node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n                return null;\n            }\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload} (must be boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                count = 0;\n                context.set(\"count\", count);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n            }\n            return null;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// Process input\nif (msg.payload === undefined || typeof msg.payload !== \"boolean\") {\n    node.warn(`Invalid input: ${msg.payload} (must be boolean)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Increment on false → true transition\nif (!prevState && msg.payload === true) {\n    count++;\n    context.set(\"count\", count);\n}\n\n// Store the current state\nprevState = msg.payload;\ncontext.set(\"prevState\", prevState);\n\n// Set output\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${count}`\n});\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2730,"y":120,"wires":[[]],"inputLabels":["input"],"outputLabels":["passthrough"],"icon":"font-awesome/fa-sort-numeric-asc","info":"Counts boolean rising edges in the input.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear count).  \r\n: payload (boolean) : Input boolean to detect rising edges.\r\n\r\n### Outputs\r\n: payload (number) : Current count of rising edges.\r\n\r\n### Details\r\nThe Count Block is a Sedona-inspired node for control systems, counting rising edges \r\nin `msg.payload` (boolean, e.g., `true` for pulse). It increments the count on false-to-true \r\ntransitions and outputs the count as `msg.payload`. Reset the count via `msg.context = \"reset\"` \r\nwith `msg.payload = true`.\r\n\r\nThe input message is passed through.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid reset\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `state reset`), blue for output (e.g., `out: 5`), red for errors."},{"id":"5a9c3371a6156f9b","type":"function","z":"1d6822e3b60ba374","g":"02978c70d9a48d66","name":"Accumulate","func":"// Initialize state from context, with defaults\nlet count = context.get(\"count\") ?? 0;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"reset\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload} (must be boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                count = 0;\n                context.set(\"count\", count);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n            }\n            return null;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// Process input\nif (msg.payload === undefined || typeof msg.payload !== \"boolean\") {\n    node.warn(`Invalid input: ${msg.payload} (must be boolean)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Accumulate or reset count\nif (msg.payload === true) {\n    count++;\n} else if (msg.payload === false) {\n    count = 0;\n}\n\n// Store the current state\ncontext.set(\"count\", count);\n\n// Set output\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${count}`\n});\n\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":2710,"y":180,"wires":[[]],"inputLabels":["input"],"outputLabels":["passthrough"],"icon":"font-awesome/fa-sort-numeric-asc","info":"Accumulates consecutive true inputs.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear count).  \r\n: payload (boolean) : Input boolean; increments count if true, resets if false.\r\n\r\n### Outputs\r\n: payload (number) : Current count of true inputs.\r\n\r\n### Details\r\nThe Accumulate Block is a Sedona-inspired node for control systems, counting `true` \r\ninputs in `msg.payload` (boolean). It increments the count for each `true` input, \r\nresets to 0 on `false`, and outputs the count as `msg.payload`. Reset the count via \r\n`msg.context = \"reset\"` with `msg.payload = true` or by sending `msg.payload = false`.\r\n\r\nThe input message is passed through.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid reset\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `state reset`), blue for output (e.g., `out: 5`), red for errors."},{"id":"db37abdaef59734d","type":"function","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Add","func":"// Initialize state from context, with defaults\nlet slots = context.get(\"slots\") ?? (this.slots ? Number(this.slots) : 2); // Default to node property or 2\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(0); // Initialize inputs array\n\n// Ensure inputs array matches slots\nif (inputs.length !== slots) {\n    inputs = Array(slots).fill(0); // Resize and reset if slots changed\n}\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"slots\":\n            let newSlots = Number(msg.payload);\n            if (isNaN(newSlots) || !Number.isInteger(newSlots) || newSlots < 1) {\n                node.warn(`Invalid slots value: ${msg.payload} (must be a positive integer)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            slots = newSlots;\n            inputs = Array(slots).fill(0); // Resize and reset inputs\n            context.set(\"slots\", slots);\n            context.set(\"inputs\", inputs);\n            node.status({ fill: \"green\", shape: \"dot\", text: `slots set: ${slots}` });\n            return null;\n        default:\n            // Check if msg.context is a valid input slot (e.g., \"in1\", \"in2\")\n            if (msg.context.startsWith(\"in\")) {\n                let slotIndex = parseInt(msg.context.slice(2)) - 1; // \"in1\" -> 0, \"in2\" -> 1\n                if (isNaN(slotIndex) || slotIndex < 0 || slotIndex >= slots) {\n                    node.warn(`Invalid input slot: ${msg.context} (must be in1 to in${slots})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input slot\" });\n                    return null;\n                }\n                if (msg.payload === undefined) {\n                    node.warn(`Invalid input: msg.payload is undefined for ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                let newValue = Number(msg.payload);\n                if (isNaN(newValue)) {\n                    node.warn(`Invalid input: ${msg.payload} (must be a number for ${msg.context})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                inputs[slotIndex] = newValue;\n                context.set(\"inputs\", inputs);\n            } else {\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n    }\n} else {\n    node.warn(\"Invalid input: msg.context missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\n    return null;\n}\n\n// Calculate sum\nconst sum = inputs.reduce((acc, val) => acc + val, 0);\n\n// Set output\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${sum.toFixed(2)}, in: ${msg.context}=${msg.payload}`\n});\n\nmsg.payload = sum;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2830,"y":400,"wires":[[]],"inputLabels":["slots"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Sums multiple numeric inputs.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear inputs, \"setSlots\" to set number of slots) or identifies input slot (e.g., \"in1\", \"in2\").  \r\n: payload (number | boolean) : Number for input slot or slots configuration, boolean for reset.\r\n\r\n### Outputs\r\n: payload (number) : Sum of all input slots.\r\n\r\n### Details\r\nThe Add Block is a Sedona-inspired node for control systems, summing numeric inputs from multiple slots identified by `msg.context` (e.g., \"in1\", \"in2\"). The number of slots is configurable via the `slots` property or `msg.context = \"setSlots\"` with `msg.payload` as a positive integer (e.g., 3). Inputs are stored in context and summed to produce `msg.payload`. Reset all inputs to 0 via `msg.context = \"reset\"` with `msg.payload = true`.\r\n\r\nThe input message is modified (`msg.payload` set to sum) and output, preserving other properties (e.g., `msg.topic`). Invalid inputs or config values are rejected with warnings. Use in automation workflows to combine numeric signals, such as sensor values.\r\n\r\n### Properties\r\n: slots (number) : Number of input slots (default: 2, minimum: 1).\r\n\r\n### Error Handling\r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, e.g., `\"abc\"`, `true`): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid reset\" (red), no output.  \r\n- Invalid slots value (non-integer, negative, or zero, e.g., `\"3\"`, `-1`, `0`): Shows \"invalid slots\" (red), no output.  \r\n- Invalid input slot (e.g., \"in5\" with 3 slots): Shows \"invalid input slot\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `state reset`, `slots set: 3`), blue for output (e.g., `out: 15, in: in2=5`), red for errors."},{"id":"f3302be055fe08db","type":"change","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Contextual In1","rules":[{"t":"set","p":"context","pt":"msg","to":"in1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":2580,"y":400,"wires":[["db37abdaef59734d","d789deaab98c681e","b9cbdebfb83c5e4b","4206724b5f1dcf3e","927b0539b644e3e7","01fd6587c9f33892","df161a565dfda2c7","f53652ab08a99953","c5230994b10ae692"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"4227ba7b6b2b525b","type":"change","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Contextual In2","rules":[{"t":"set","p":"context","pt":"msg","to":"in2","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":2560,"y":700,"wires":[["db37abdaef59734d","d789deaab98c681e","4206724b5f1dcf3e","b9cbdebfb83c5e4b","927b0539b644e3e7","01fd6587c9f33892","df161a565dfda2c7","f53652ab08a99953","c5230994b10ae692"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"8de672f8c66c6a0f","type":"inject","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"72","payloadType":"num","x":2410,"y":400,"wires":[["f3302be055fe08db","72e363ad9893b593","5eb0fb0078391fe1"]]},{"id":"d789deaab98c681e","type":"function","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Sub","func":"// Initialize state from context, with defaults\nlet slots = context.get(\"slots\") ?? (this.slots ? Number(this.slots) : 2); // Default to node property or 2\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(0); // Initialize inputs array\n\n// Ensure inputs array matches slots\nif (inputs.length !== slots) {\n    inputs = Array(slots).fill(0); // Resize and reset if slots changed\n}\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"reset\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload} (must be boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                inputs = Array(slots).fill(0);\n                context.set(\"inputs\", inputs);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n                return null;\n            }\n            return null;\n        case \"slots\":\n            let newSlots = Number(msg.payload);\n            if (isNaN(newSlots) || !Number.isInteger(newSlots) || newSlots < 1) {\n                node.warn(`Invalid slots value: ${msg.payload} (must be a positive integer)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            slots = newSlots;\n            inputs = Array(slots).fill(0); // Resize and reset inputs\n            context.set(\"slots\", slots);\n            context.set(\"inputs\", inputs);\n            node.status({ fill: \"green\", shape: \"dot\", text: `slots set: ${slots}` });\n            return null;\n        default:\n            // Check if msg.context is a valid input slot (e.g., \"in1\", \"in2\")\n            if (msg.context.startsWith(\"in\")) {\n                let slotIndex = parseInt(msg.context.slice(2)) - 1; // \"in1\" -> 0, \"in2\" -> 1\n                if (isNaN(slotIndex) || slotIndex < 0 || slotIndex >= slots) {\n                    node.warn(`Invalid input slot: ${msg.context} (must be in1 to in${slots})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input slot\" });\n                    return null;\n                }\n                if (msg.payload === undefined) {\n                    node.warn(`Invalid input: msg.payload is undefined for ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                let newValue = Number(msg.payload);\n                if (isNaN(newValue)) {\n                    node.warn(`Invalid input: ${msg.payload} (must be a number for ${msg.context})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                inputs[slotIndex] = newValue;\n                context.set(\"inputs\", inputs);\n            } else {\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n    }\n} else {\n    node.warn(\"Invalid input: msg.context missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\n    return null;\n}\n\n// Calculate subtraction\nconst result = inputs.reduce((acc, val, idx) => idx === 0 ? val : acc - val, 0);\n\n// Set output\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${result.toFixed(2)}, in: ${msg.context}=${msg.payload}`\n});\n\nmsg.payload = result;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2830,"y":500,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Subtracts multiple numeric inputs in sequence.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear inputs, \"slots\" to set number of slots) or identifies input slot (e.g., \"in1\", \"in2\").  \r\n: payload (number | boolean) : Number for input slot or slots configuration, boolean for reset.\r\n\r\n### Outputs\r\n: payload (number) : Result of subtracting input slots in sequence.\r\n\r\n### Details\r\nThe Subtract Block is a Sedona-inspired node for control systems, subtracting numeric inputs from multiple slots identified by `msg.context` (e.g., \"in1\", \"in2\") in sequence (in1 - in2 - in3 - ...). The number of slots is configurable via the `slots` property or `msg.context = \"slots\"` with `msg.payload` as a positive integer (e.g., 3). Inputs are stored in context and subtracted to produce `msg.payload`. Reset all inputs to 0 via `msg.context = \"reset\"` with `msg.payload = true`.\r\n\r\nThe input message is modified (`msg.payload` set to result) and output, preserving other properties (e.g., `msg.topic`). Invalid inputs or config values are rejected with warnings. Use in automation workflows to compute differences, such as sensor value offsets.\r\n\r\n### Properties\r\n: slots (number) : Number of input slots (default: 2, minimum: 1).\r\n\r\n### Error Handling\r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, e.g., `\"abc\"`, `true`): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid reset\" (red), no output.  \r\n- Invalid slots value (non-integer, negative, or zero, e.g., `\"3\"`, `-1`, `0`): Shows \"invalid slots\" (red), no output.  \r\n- Invalid input slot (e.g., \"in5\" with 3 slots): Shows \"invalid input slot\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `state reset`, `slots set: 3`), blue for output (e.g., `out: 5, in: in2=3`), red for errors."},{"id":"e73fbc28f443845a","type":"inject","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"14","payloadType":"num","x":2390,"y":700,"wires":[["4227ba7b6b2b525b","72e363ad9893b593"]]},{"id":"b9cbdebfb83c5e4b","type":"function","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Mul","func":"// Initialize state\nlet slots = context.get(\"slots\") ?? (this.slots ? Number(this.slots) : 2);\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(1); // Default to 1 for multiplication\n\n// Ensure inputs array matches slots\nif (inputs.length !== slots) {\n    inputs = Array(slots).fill(1);\n}\n\n// Handle configuration\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"reset\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                inputs = Array(slots).fill(1);\n                context.set(\"inputs\", inputs);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n                return null;\n            }\n            return null;\n        case \"slots\":\n            let newSlots = Number(msg.payload);\n            if (isNaN(newSlots) || !Number.isInteger(newSlots) || newSlots < 1) {\n                node.warn(`Invalid slots value: ${msg.payload}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            slots = newSlots;\n            inputs = Array(slots).fill(1);\n            context.set(\"slots\", slots);\n            context.set(\"inputs\", inputs);\n            node.status({ fill: \"green\", shape: \"dot\", text: `slots set: ${slots}` });\n            return null;\n        default:\n            if (msg.context.startsWith(\"in\")) {\n                let slotIndex = parseInt(msg.context.slice(2)) - 1;\n                if (isNaN(slotIndex) || slotIndex < 0 || slotIndex >= slots) {\n                    node.warn(`Invalid input slot: ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input slot\" });\n                    return null;\n                }\n                if (msg.payload === undefined) {\n                    node.warn(`Invalid input: msg.payload undefined for ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                let newValue = Number(msg.payload);\n                if (isNaN(newValue)) {\n                    node.warn(`Invalid input: ${msg.payload} for ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                inputs[slotIndex] = newValue;\n                context.set(\"inputs\", inputs);\n            } else {\n                node.warn(`Unrecognized context: ${msg.context}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n    }\n} else {\n    node.warn(\"Invalid input: msg.context missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\n    return null;\n}\n\n// Calculate product\nconst result = inputs.reduce((acc, val) => acc * val, 1);\n\n// Set output\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${result.toFixed(2)}, in: ${msg.context}=${msg.payload}`\n});\n\nmsg.payload = result;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2830,"y":600,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Multiplies multiple numeric inputs.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear inputs, \"slots\" to set number of slots) or identifies input slot (e.g., \"in1\", \"in2\").  \r\n: payload (number | boolean) : Number for input slot or slots configuration, boolean for reset.\r\n\r\n### Outputs\r\n: payload (number) : Product of all input slots.\r\n\r\n### Details\r\nMultiplies numeric inputs from slots identified by `msg.context` (e.g., \"in1\", \"in2\") in sequence (in1 * in2 * ...). \r\nConfigure slots via `slots` property or `msg.context = \"slots\"` with `msg.payload` as a positive integer. \r\nReset inputs to 1 via `msg.context = \"reset\"` with `msg.payload = true`. Inputs are stored in context, \r\nand `msg.payload` is set to the product. Invalid inputs or config are rejected.\r\n\r\n### Properties\r\n: slots (number) : Number of input slots (default: 2, minimum: 1).\r\n\r\n### Error Handling\r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean): Shows \"invalid reset\" (red), no output.  \r\n- Invalid slots value (non-integer, <= 0): Shows \"invalid slots\" (red), no output.  \r\n- Invalid input slot: Shows \"invalid input slot\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus: green for config (e.g., `state reset`, `slots set: 3`), blue for output (e.g., `out: 15, in: in2=5`), red for errors."},{"id":"4206724b5f1dcf3e","type":"function","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Div","func":"// Initialize state\nlet slots = context.get(\"slots\") ?? (this.slots ? Number(this.slots) : 2);\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(1); // Default to 1 for division\n\n// Ensure inputs array matches slots\nif (inputs.length !== slots) {\n    inputs = Array(slots).fill(1);\n}\n\n// Handle configuration\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"reset\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                inputs = Array(slots).fill(1);\n                context.set(\"inputs\", inputs);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n                return null;\n            }\n            return null;\n        case \"slots\":\n            let newSlots = Number(msg.payload);\n            if (isNaN(newSlots) || !Number.isInteger(newSlots) || newSlots < 1) {\n                node.warn(`Invalid slots value: ${msg.payload}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            slots = newSlots;\n            inputs = Array(slots).fill(1);\n            context.set(\"slots\", slots);\n            context.set(\"inputs\", inputs);\n            node.status({ fill: \"green\", shape: \"dot\", text: `slots set: ${slots}` });\n            return null;\n        default:\n            if (msg.context.startsWith(\"in\")) {\n                let slotIndex = parseInt(msg.context.slice(2)) - 1;\n                if (isNaN(slotIndex) || slotIndex < 0 || slotIndex >= slots) {\n                    node.warn(`Invalid input slot: ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input slot\" });\n                    return null;\n                }\n                if (msg.payload === undefined) {\n                    node.warn(`Invalid input: msg.payload undefined for ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                let newValue = Number(msg.payload);\n                if (isNaN(newValue)) {\n                    node.warn(`Invalid input: ${msg.payload} for ${msg.context}`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n                    return null;\n                }\n                if (slotIndex > 0 && newValue === 0) {\n                    node.warn(`Invalid input: ${msg.payload} (cannot divide by zero for ${msg.context})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: \"divide by zero\" });\n                    return null;\n                }\n                inputs[slotIndex] = newValue;\n                context.set(\"inputs\", inputs);\n            } else {\n                node.warn(`Unrecognized context: ${msg.context}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n    }\n} else {\n    node.warn(\"Invalid input: msg.context missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\n    return null;\n}\n\n// Calculate division\nconst result = inputs.reduce((acc, val, idx) => idx === 0 ? val : acc / val, 1);\n\n// Set output\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${result.toFixed(2)}, in: ${msg.context}=${msg.payload}`\n});\n\nmsg.payload = result;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2830,"y":700,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Divides multiple numeric inputs in sequence.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear inputs, \"slots\" to set number of slots) or identifies input slot (e.g., \"in1\", \"in2\").  \r\n: payload (number | boolean) : Number for input slot or slots configuration, boolean for reset.\r\n\r\n### Outputs\r\n: payload (number) : Result of dividing input slots in sequence.\r\n\r\n### Details\r\nDivides numeric inputs from slots identified by `msg.context` (e.g., \"in1\", \"in2\") in sequence (in1 / in2 / ...). \r\nConfigure slots via `slots` property or \r\n`msg.context = \"slots\"` with `msg.payload` as a positive integer. Reset inputs to 1 via `msg.context = \"reset\"` \r\nwith `msg.payload = true`. Inputs are stored in context, and `msg.payload` is set to the result. Invalid inputs, \r\nincluding zero divisors, or config are rejected.\r\n\r\n### Properties\r\n: slots (number) : Number of input slots (default: 2, minimum: 1).\r\n\r\n### Error Handling\r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, or zero for in2 onward): Shows \"invalid input\" or \"divide by zero\" (red), no output.  \r\n- Invalid reset value (non-boolean): Shows \"invalid reset\" (red), no output.  \r\n- Invalid slots value (non-integer, <= 0): Shows \"invalid slots\" (red), no output.  \r\n- Invalid input slot: Shows \"invalid input slot\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus: green for config (e.g., `state reset`, `slots set: 3`), blue for output (e.g., `out: 5, in: in2=2`), red for errors."},{"id":"892c9e4dd092b13e","type":"inject","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":2390,"y":760,"wires":[["0333dc50b1d77108","4b460e51fa20f61c"]]},{"id":"6998ab79fb3e949d","type":"inject","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"false","payloadType":"bool","x":2390,"y":820,"wires":[["0333dc50b1d77108","4b460e51fa20f61c"]]},{"id":"e955ed10ed02fe4d","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Hysteresis","func":"// Initialize state\nlet prevState = context.get(\"prevState\") ?? \"within\";\nlet upperLimit = context.get(\"upperLimit\") ?? (this.upperLimit ? Number(this.upperLimit) : 50);\nlet lowerLimit = context.get(\"lowerLimit\") ?? (this.lowerLimit ? Number(this.lowerLimit) : 30);\n\n// Handle configuration\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"upperLimit\":\n            let newUpperLimit = Number(msg.payload);\n            if (isNaN(newUpperLimit)) {\n                node.warn(`Invalid upperLimit: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid upperLimit\" });\n                return null;\n            }\n            if (newUpperLimit <= lowerLimit) {\n                node.warn(`Invalid upperLimit: ${newUpperLimit} (must be greater than lowerLimit ${lowerLimit})`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid upperLimit\" });\n                return null;\n            }\n            upperLimit = newUpperLimit;\n            context.set(\"upperLimit\", upperLimit);\n            node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set: ${upperLimit}` });\n            return null;\n        case \"lowerLimit\":\n            let newLowerLimit = Number(msg.payload);\n            if (isNaN(newLowerLimit)) {\n                node.warn(`Invalid lowerLimit: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid lowerLimit\" });\n                return null;\n            }\n            if (newLowerLimit >= upperLimit) {\n                node.warn(`Invalid lowerLimit: ${newLowerLimit} (must be less than upperLimit ${upperLimit})`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid lowerLimit\" });\n                return null;\n            }\n            lowerLimit = newLowerLimit;\n            context.set(\"lowerLimit\", lowerLimit);\n            node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set: ${lowerLimit}` });\n            return null;\n        default:\n            node.warn(`Unrecognized context: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// Process input\nif (msg.payload === undefined || isNaN(Number(msg.payload))) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\nlet value = Number(msg.payload);\n\n// Determine new state\nlet newState;\nif (value > upperLimit) {\n    newState = \"above\";\n} else if (value < lowerLimit) {\n    newState = \"below\";\n} else {\n    newState = \"within\";\n}\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: `out: ${newState}, in: ${value.toFixed(2)}` });\n\n// Handle state change\nif (newState !== prevState) {\n    prevState = newState;\n    context.set(\"prevState\", prevState);\n    let output = [{ payload: false }, { payload: false }, { payload: false }];\n    if (newState === \"above\") {\n        output[0] = { payload: true };\n    } else if (newState === \"below\") {\n        output[2] = { payload: true };\n    } else {\n        output[1] = { payload: true };\n    }\n    return output;\n}\n\nreturn null;","outputs":3,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":530,"y":980,"wires":[[],[],[]],"inputLabels":["input"],"outputLabels":["above","within","below"],"icon":"font-awesome/fa-wrench","info":"Evaluates numeric input against limits with hysteresis.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear state, \"upperLimit\" to set upper limit, \"lowerLimit\" to set lower limit).  \r\n: payload (number | boolean) : Number for evaluation, boolean for reset.\r\n\r\n### Outputs\r\n: 1 (boolean) : True when above upper limit.  \r\n: 2 (boolean) : True when within limits.  \r\n: 3 (boolean) : True when below lower limit.\r\n\r\n### Details\r\nEvaluates `msg.payload` (number) against `upperLimit` and `lowerLimit` with hysteresis, outputting `true` \r\nto one output on state change: `above` (output 1), `within` (output 2), `below` (output 3). Configure limits \r\nvia `upperLimit` and `lowerLimit` properties, `msg.context = \"upperLimit\"`, or `msg.context = \"lowerLimit\"` \r\nwith `msg.payload` as a number. Reset state to `within` via `msg.context = \"reset\"` with `msg.payload = true`. \r\nInvalid inputs or config are rejected.\r\n\r\n### Properties\r\n: upperLimit (number) : Upper threshold (default: 50).  \r\n: lowerLimit (number) : Lower threshold (default: 30).\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean, not true): Shows \"invalid reset\" (red), no output.  \r\n- Invalid upperLimit (non-numeric, <= lowerLimit): Shows \"invalid upperLimit\" (red), no output.  \r\n- Invalid lowerLimit (non-numeric, >= upperLimit): Shows \"invalid lowerLimit\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus: green for config (e.g., `state reset`, `upperLimit set: 50`), blue for input (e.g., `in: 40`) \r\nand output (e.g., `out: within, in: 40`), red for errors."},{"id":"239a068ef3d5218f","type":"random","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","low":"10","high":"100","inte":"false","property":"payload","x":320,"y":980,"wires":[["e955ed10ed02fe4d","0999e4ec2194ecab"]]},{"id":"302ebae443b08436","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Inject Flow","props":[],"repeat":"5","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":150,"y":980,"wires":[["239a068ef3d5218f"]]},{"id":"1872f6ae789c94e3","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Analog Switch","func":"// Initialize state from context, with defaults\nlet slots = context.get(\"slots\") ?? 2;\nlet inputs = context.get(\"inputs\") ?? Array(slots).fill(0);\nlet s1 = context.get(\"s1\") ?? 1; // Default s1 to 1 (1-based)\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"slots\":\n            let slotValue = parseInt(msg.payload, 10);\n            if (!isNaN(slotValue) && slotValue >= 1) {\n                slots = slotValue;\n                // Resize inputs array, preserving existing values where possible\n                let newInputs = Array(slots).fill(0);\n                for (let i = 0; i < Math.min(inputs.length, slots); i++) {\n                    newInputs[i] = inputs[i];\n                }\n                inputs = newInputs;\n                // Adjust s1 if out of range\n                if (s1 > slots) {\n                    s1 = 1;\n                }\n                context.set(\"slots\", slots);\n                context.set(\"inputs\", inputs);\n                context.set(\"s1\", s1);\n                node.status({ fill: \"green\", shape: \"dot\", text: `slots set to ${slots}` });\n            } else {\n                node.warn(`Invalid slots value: ${msg.payload} (must be an integer >= 1)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid slots\" });\n                return null;\n            }\n            break;\n        case \"switch\":\n            let switchValue = parseInt(msg.payload, 10);\n            if (!isNaN(switchValue) && switchValue >= 1 && switchValue <= slots) {\n                s1 = switchValue;\n                context.set(\"s1\", s1);\n                node.status({ fill: \"green\", shape: \"dot\", text: `switch set to ${s1}` });\n            } else {\n                node.warn(`Invalid switch value: ${msg.payload} (must be an integer in [1, ${slots}], slots=${slots})`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid switch\" });\n                return null;\n            }\n            break;\n        default:\n            // Check for dynamic input context (in1, in2, etc.)\n            if (msg.context.startsWith(\"in\")) {\n                let index = parseInt(msg.context.slice(2), 10);\n                if (!isNaN(index) && index >= 1 && index <= slots) {\n                    let value = Number(msg.payload);\n                    if (!isNaN(value)) {\n                        inputs[index - 1] = value; // Map 1-based to 0-based\n                        context.set(\"inputs\", inputs);\n                        node.status({\n                            fill: \"green\",\n                            shape: \"dot\",\n                            text: `in${index} set to ${value.toFixed(2)}`\n                        });\n                    } else {\n                        node.warn(`Invalid input value: ${msg.payload} (must be a number)`);\n                        node.status({ fill: \"red\", shape: \"ring\", text: `invalid in${index}` });\n                        return null;\n                    }\n                } else {\n                    node.warn(`Invalid input index: ${msg.context} (valid: in1 to in${slots})`);\n                    node.status({ fill: \"red\", shape: \"ring\", text: `invalid input index ${index}` });\n                    return null;\n                }\n            } else {\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n                return null;\n            }\n            break;\n    }\n} else {\n    node.warn(\"Invalid input: msg.context missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\n    return null;\n}\n\n// Set output\nlet out = inputs[s1 - 1] ?? inputs[0]; // Map 1-based s1 to 0-based index\nlet newMsg = { payload: out };\n\n// Set status\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${out.toFixed(2)}, in: [${inputs.map(v => v.toFixed(1)).join(\", \")}]`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":1200,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Selects one numeric input from multiple slots based on an integer switch.\r\n\r\n### Inputs\r\n: context (string) : Identifies input (\"slots\" for number of inputs, \"switch\" for selection, \"in1\", \"in2\", ... for values).  \r\n: payload (number | integer) : Number for inX, integer for slots/switch.\r\n\r\n### Outputs\r\n: 1 (number) : Selected input (in(switch), e.g., in1 if switch=1).\r\n\r\n### Details\r\nSelects one numeric input from a dynamic number of slots (default: 1) based on a switch (`s1`, 1 to slots). Set number of slots via `msg.context = \"slots\"` with `msg.payload` (integer >= 1). Set switch via `msg.context = \"switch\"` with `msg.payload` (integer in [1, slots]). Update inputs via `msg.context = \"inX\"` (e.g., \"in1\") with `msg.payload` (number). Outputs the selected input (`in(s1)`) to `msg.payload`. Invalid or non-config messages (missing `msg.context`) are rejected. Use in automation to switch between multiple analog signals.\r\n\r\n### Error Handling\r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid slots (non-integer, < 1): Shows \"invalid slots\" (red), no output.  \r\n- Invalid switch (non-integer, out of [1, slots]): Shows \"invalid switch\" (red), no output.  \r\n- Invalid inX (invalid index, non-numeric): Shows \"invalid inX\" or \"invalid input index X\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `slots set to 3`, `in1 set to 5.00`), blue for output (e.g., `out: 5.00, in: [5.00, 0.00]`), red for errors, yellow for unknown context."},{"id":"c982d77c48ea3f7a","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual In1","rules":[{"t":"set","p":"context","pt":"msg","to":"in1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":300,"y":1120,"wires":[["1872f6ae789c94e3","0520e98abca50ad5"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"57a1e99b38d1339d","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual In2","rules":[{"t":"set","p":"context","pt":"msg","to":"in2","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":300,"y":1160,"wires":[["1872f6ae789c94e3","0520e98abca50ad5"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"727da4e3e54228da","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual Switch","rules":[{"t":"set","p":"context","pt":"msg","to":"switch","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":310,"y":1080,"wires":[["1872f6ae789c94e3","0520e98abca50ad5"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"12814af20e1fb45a","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"72","payloadType":"num","x":130,"y":1120,"wires":[["c982d77c48ea3f7a"]]},{"id":"d0a59a9da07466bc","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"14","payloadType":"num","x":130,"y":1160,"wires":[["57a1e99b38d1339d"]]},{"id":"6f8d8280c2b877e1","type":"function","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Triangle Wave","func":"// Initialize state from context, with defaults\nlet lastExecution = context.get(\"lastExecution\") ?? Date.now();\nlet phase = context.get(\"phase\") ?? 0;\nlet lowerLimit = context.get(\"lowerLimit\") ?? 0;\nlet upperLimit = context.get(\"upperLimit\") ?? 100;\nlet period = context.get(\"period\") ?? 10;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    let value = Number(msg.payload);\n    if (isNaN(value)) {\n        node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n        node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n        return null;\n    }\n    switch (msg.context) {\n        case \"lowerLimit\":\n            lowerLimit = value;\n            if (lowerLimit > upperLimit) {\n                upperLimit = lowerLimit;\n                context.set(\"upperLimit\", upperLimit);\n                node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set to ${lowerLimit.toFixed(2)}, upperLimit adjusted to ${upperLimit.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set to ${lowerLimit.toFixed(2)}` });\n            }\n            context.set(\"lowerLimit\", lowerLimit);\n            break;\n        case \"upperLimit\":\n            upperLimit = value;\n            if (upperLimit < lowerLimit) {\n                lowerLimit = upperLimit;\n                context.set(\"lowerLimit\", lowerLimit);\n                node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set to ${upperLimit.toFixed(2)}, lowerLimit adjusted to ${lowerLimit.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set to ${upperLimit.toFixed(2)}` });\n            }\n            context.set(\"upperLimit\", upperLimit);\n            break;\n        case \"period\":\n            if (value <= 0) {\n                node.warn(`Invalid period value: ${msg.payload} (must be positive)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid period\" });\n                return null;\n            }\n            period = value;\n            context.set(\"period\", period);\n            node.status({ fill: \"green\", shape: \"dot\", text: `period set to ${period.toFixed(2)}` });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    return null; // Stop processing after configuration update\n}\n\n// Calculate time difference\nlet now = Date.now();\nlet deltaTime = (now - lastExecution) / 1000; // Convert ms to seconds\nlastExecution = now;\ncontext.set(\"lastExecution\", lastExecution);\n\n// Reset to lower limit if period is zero\nif (period <= 0) {\n    let newMsg = { payload: lowerLimit };\n    node.status({ fill: \"blue\", shape: \"dot\", text: `out: ${lowerLimit.toFixed(2)}, phase: ${phase.toFixed(2)}` });\n    return newMsg;\n}\n\n// Compute phase shift\nphase = (phase + deltaTime / period) % 1;\ncontext.set(\"phase\", phase);\n\n// Triangle wave calculation (normalized between -1 and 1)\nlet triangleValue = phase < 0.5\n    ? 2 * phase - 1   // Rising ramp (scaled from -1 to 1)\n    : 1 - 2 * (phase - 0.5); // Falling ramp (scaled from 1 to -1)\n\n// Scale triangle wave to the specified range\nlet amplitude = (upperLimit - lowerLimit) / 2;\nlet value = lowerLimit + amplitude * (triangleValue + 1);\n\nlet newMsg = { payload: value };\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${value.toFixed(2)}, phase: ${phase.toFixed(2)}`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2800,"y":980,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Generates a triangle wave output scaled to a configurable range.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"lowerLimit\", \"upperLimit\", \"period\").  \r\n: payload (number) : Config value for lowerLimit/upperLimit/period.\r\n\r\n### Outputs\r\n: 1 (number) : Triangle wave value scaled between lowerLimit and upperLimit.\r\n\r\n### Details\r\nGenerates a triangle wave output based on time, scaled between `lowerLimit` and `upperLimit` over a `period` (seconds). \r\nTracks phase (0 to 1) to maintain continuity, producing a linear rise from -1 to 1 and fall from 1 to -1. \r\nConfigure via `msg.context = \"lowerLimit\"`, `\"upperLimit\"`, `\"period\"` with numeric values. Ensures `upperLimit ≥ lowerLimit` \r\nby adjusting the other value if needed. Returns `lowerLimit` if `period ≤ 0`. Invalid configurations are rejected. \r\nUse in automation for testing or signal generation.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid lowerLimit/upperLimit/period (non-numeric): Shows \"invalid lowerLimit\" (red), no output.  \r\n- Invalid period (non-positive for triangle wave): Shows \"invalid period\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `lowerLimit set to 0.00`, `upperLimit set to 100.00, lowerLimit adjusted to 50.00`), \r\nblue for output (e.g., `out: 50.00, phase: 0.25`), red for errors, yellow for unknown context."},{"id":"703a9a1e9e8fad43","type":"function","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Saw-Tooth Wave","func":"// Initialize state from context, with defaults\nlet lastExecution = context.get(\"lastExecution\") ?? Date.now();\nlet phase = context.get(\"phase\") ?? 0;\nlet lowerLimit = context.get(\"lowerLimit\") ?? 0;\nlet upperLimit = context.get(\"upperLimit\") ?? 100;\nlet period = context.get(\"period\") ?? 10;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    let value = Number(msg.payload);\n    if (isNaN(value)) {\n        node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n        node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n        return null;\n    }\n    switch (msg.context) {\n        case \"lowerLimit\":\n            lowerLimit = value;\n            if (lowerLimit > upperLimit) {\n                upperLimit = lowerLimit;\n                context.set(\"upperLimit\", upperLimit);\n                node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set to ${lowerLimit.toFixed(2)}, upperLimit adjusted to ${upperLimit.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set to ${lowerLimit.toFixed(2)}` });\n            }\n            context.set(\"lowerLimit\", lowerLimit);\n            break;\n        case \"upperLimit\":\n            upperLimit = value;\n            if (upperLimit < lowerLimit) {\n                lowerLimit = upperLimit;\n                context.set(\"lowerLimit\", lowerLimit);\n                node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set to ${upperLimit.toFixed(2)}, lowerLimit adjusted to ${lowerLimit.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set to ${upperLimit.toFixed(2)}` });\n            }\n            context.set(\"upperLimit\", upperLimit);\n            break;\n        case \"period\":\n            if (value <= 0) {\n                node.warn(`Invalid period value: ${msg.payload} (must be positive)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid period\" });\n                return null;\n            }\n            period = value;\n            context.set(\"period\", period);\n            node.status({ fill: \"green\", shape: \"dot\", text: `period set to ${period.toFixed(2)}` });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    return null; // Stop processing after configuration update\n}\n\n// Calculate time difference\nlet now = Date.now();\nlet deltaTime = (now - lastExecution) / 1000; // Convert ms to seconds\nlastExecution = now;\ncontext.set(\"lastExecution\", lastExecution);\n\n// Reset to lower limit if period is zero\nif (period <= 0) {\n    let newMsg = { payload: lowerLimit };\n    node.status({ fill: \"blue\", shape: \"dot\", text: `out: ${lowerLimit.toFixed(2)}, phase: ${phase.toFixed(2)}` });\n    return newMsg;\n}\n\n// Compute phase shift\nphase = (phase + deltaTime / period) % 1;\ncontext.set(\"phase\", phase);\n\n// Sawtooth wave calculation\nlet amplitude = upperLimit - lowerLimit;\nlet value = lowerLimit + amplitude * phase;\n\nlet newMsg = { payload: value };\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${value.toFixed(2)}, phase: ${phase.toFixed(2)}`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2810,"y":1040,"wires":[["6a62f8e0fe1fad2a"]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Generates a sawtooth wave output scaled to a configurable range.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"lowerLimit\", \"upperLimit\", \"period\").  \r\n: payload (number) : Config value for lowerLimit/upperLimit/period.\r\n\r\n### Outputs\r\n: 1 (number) : Sawtooth wave value scaled between lowerLimit and upperLimit.\r\n\r\n### Details\r\nGenerates a sawtooth wave output based on time, scaled between `lowerLimit` and `upperLimit` over a `period` (seconds). \r\nTracks phase (0 to 1) to maintain continuity, producing a linear ramp from `lowerLimit` to `upperLimit` followed by a sharp drop. \r\nConfigure via `msg.context = \"lowerLimit\"`, `\"upperLimit\"`, `\"period\"` with numeric values. Ensures `upperLimit ≥ lowerLimit` \r\nby adjusting the other value if needed. Returns `lowerLimit` if `period ≤ 0`. Invalid configurations are rejected. \r\nUse in automation for testing or signal generation.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid lowerLimit/upperLimit/period (non-numeric): Shows \"invalid lowerLimit\" (red), no output.  \r\n- Invalid period (non-positive for sawtooth wave): Shows \"invalid period\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `lowerLimit set to 0.00`, `upperLimit set to 100.00, lowerLimit adjusted to 50.00`), \r\nblue for output (e.g., `out: 50.00, phase: 0.50`), red for errors, yellow for unknown context."},{"id":"acd036852cf5dcb2","type":"inject","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Inject Flow","props":[],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":2410,"y":980,"wires":[["6f8d8280c2b877e1","703a9a1e9e8fad43","1f23ada6b13f037b","e78c5e13c2b2acbd","4fd0b55f30005e8c"]]},{"id":"667e13fa6fbd88a4","type":"function","z":"1d6822e3b60ba374","g":"08570307a3388294","name":"Negate","func":"// Process input from msg.payload\nconst inputValue = msg.payload;\n\n// Handle number input\nif (typeof inputValue === 'number' && !isNaN(inputValue)) {\n    msg.payload = -inputValue;\n    node.status({ fill: \"blue\", shape: \"dot\", text: `in: ${inputValue}, out: ${msg.payload}` });\n    return msg;\n}\n// Handle boolean input\nelse if (typeof inputValue === 'boolean') {\n    msg.payload = !inputValue;\n    node.status({ fill: \"blue\", shape: \"dot\", text: `in: ${inputValue.toFixed(2)}, out: ${msg.payload.toFixed(2)}` });\n    return msg;\n}\n// Handle invalid inputs\nelse {\n    let errorText;\n    if (inputValue === null) {\n        errorText = \"null input\";\n    } else if (Array.isArray(inputValue)) {\n        errorText = \"array input\";\n    } else if (typeof inputValue === 'string') {\n        errorText = \"string input\";\n    } else {\n        errorText = \"invalid input type\";\n    }\n    node.warn(`Invalid input: ${errorText}`);\n    node.status({ fill: \"red\", shape: \"ring\", text: errorText });\n    return null;\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1760,"y":480,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Negates a number or boolean input value.\r\n\r\n### Inputs\r\n: payload (number | boolean) : Value to negate (number or boolean).\r\n\r\n### Outputs\r\n: payload (number | boolean) : Negated value (-number or !boolean). (the existing message is modified and output)\r\n\r\n### Details\r\nThe NEGATE Block is a Sedona-inspired node for control systems, negating `msg.payload`. \r\n\r\nFor numbers, it outputs the negative (e.g., `5` > `-5`). \r\n\r\nFor booleans, it outputs the inverse (e.g., `true` > `false`). Invalid inputs (e.g., strings, arrays, null) are rejected with a warning.\r\n\r\n### Error Handling\r\n- Invalid input (null, array, string, etc.): Shows \"null input\", \"array input\", \"string input\", or \"invalid input type\" (red), no output.  \r\n- Invalid number (NaN): Shows \"invalid input type\" (red), no output.  \r\n\r\nStatus shows blue for output (e.g., `in: 5, out: -5`), red for errors (e.g., `string input`)."},{"id":"672b7c30e77da6a6","type":"inject","z":"1d6822e3b60ba374","g":"08570307a3388294","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"false","payloadType":"bool","x":1350,"y":480,"wires":[["667e13fa6fbd88a4","4048fdc688a79374"]]},{"id":"61f4ddf31b9548d9","type":"inject","z":"1d6822e3b60ba374","g":"08570307a3388294","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"14","payloadType":"num","x":1350,"y":420,"wires":[["667e13fa6fbd88a4","4048fdc688a79374"]]},{"id":"585a2a5143cdc7f4","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Scale Reset Range","func":"// Default configuration values\nconst defaults = {\n    inMin: 0.0,\n    inMax: 100.0,\n    outMin: 0.0,\n    outMax: 80.0,\n    clamp: true\n};\n\n// Load configuration from context or use defaults\nlet inMin = context.get(\"inMin\") ?? defaults.inMin;\nlet inMax = context.get(\"inMax\") ?? defaults.inMax;\nlet outMin = context.get(\"outMin\") ?? defaults.outMin;\nlet outMax = context.get(\"outMax\") ?? defaults.outMax;\nlet clamp = context.get(\"clamp\") ?? defaults.clamp;\nlet lastInput = context.get(\"lastInput\") ?? defaults.inMin;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"inMin\":\n        case \"inMax\":\n        case \"outMin\":\n        case \"outMax\":\n            let value = Number(msg.payload);\n            if (isNaN(value)) {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if (msg.context === \"inMin\") inMin = value;\n            else if (msg.context === \"inMax\") inMax = value;\n            else if (msg.context === \"outMin\") outMin = value;\n            else outMax = value;\n            context.set(msg.context, value);\n            // Validate ranges\n            if (inMax <= inMin) {\n                node.warn(`Invalid input range: inMax (${inMax}) must be greater than inMin (${inMin})`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input range\" });\n                return null;\n            }\n            if (outMax <= outMin) {\n                node.warn(`Invalid output range: outMax (${outMax}) must be greater than outMin (${outMin})`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid output range\" });\n                return null;\n            }\n            node.status({ fill: \"green\", shape: \"dot\", text: `${msg.context} set to ${value.toFixed(2)}` });\n            break;\n        case \"clamp\":\n            let clampValue = Boolean(msg.payload);\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid clamp value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid clamp\" });\n                return null;\n            }\n            clamp = clampValue;\n            context.set(\"clamp\", clamp);\n            node.status({ fill: \"green\", shape: \"dot\", text: `clamp set to ${clamp}` });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    // Recalculate with last input after config update\n    let inputValue = lastInput;\n    let out = calculate(inputValue, { inMin, inMax, outMin, outMax, clamp });\n    let newMsg = { payload: out };\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `out: ${out.toFixed(2)}, in: ${inputValue.toFixed(2)}`\n    });\n    return newMsg;\n}\n\n// Process input\nlet inputValue = Number(msg.payload);\nif (isNaN(inputValue)) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n// Validate ranges\nif (inMax <= inMin) {\n    node.warn(`Invalid input range: inMax (${inMax}) must be greater than inMin (${inMin})`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input range\" });\n    return null;\n}\nif (outMax <= outMin) {\n    node.warn(`Invalid output range: outMax (${outMax}) must be greater than outMin (${outMin})`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid output range\" });\n    return null;\n}\n// Cache input\nlastInput = inputValue;\ncontext.set(\"lastInput\", lastInput);\n// Calculate output\nlet out = calculate(inputValue, { inMin, inMax, outMin, outMax, clamp });\nlet newMsg = { payload: out };\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${out.toFixed(2)}, in: ${inputValue.toFixed(2)}`\n});\nreturn newMsg;\n\n// Scaling function\nfunction calculate(input, { inMin, inMax, outMin, outMax, clamp }) {\n    const scaleRatio = (outMax - outMin) / (inMax - inMin);\n    let output = scaleRatio * (input - inMin) + outMin;\n    return clamp ? Math.max(outMin, Math.min(outMax, output)) : output;\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":550,"y":1260,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Scales a numeric input from one range to another with optional clamping.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"inMin\", \"inMax\", \"outMin\", \"outMax\", \"clamp\").  \r\n: payload (number | boolean) : Number for input/inMin/inMax/outMin/outMax, boolean for clamp.\r\n\r\n### Outputs\r\n: 1 (number) : Scaled output.\r\n\r\n### Details\r\nScales a numeric input (`msg.payload`) from an input range (`inMin` to `inMax`) to an output range (`outMin` to `outMax`), \r\nwith optional clamping (`clamp`). Configure via `msg.context = \"inMin\"`, `inMax`, `outMin`, `outMax` (numbers), or `clamp` (boolean). \r\nNon-config messages scale the input. Config updates trigger recalculation using the last input. Invalid inputs or \r\nconfigurations are rejected. Use in automation to map sensor values to control ranges.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid inMin/inMax/outMin/outMax (non-numeric): Shows \"invalid inMin\" (red), no output.  \r\n- Invalid clamp (non-boolean): Shows \"invalid clamp\" (red), no output.  \r\n- Invalid input range (inMax <= inMin): Shows \"invalid input range\" (red), no output.  \r\n- Invalid output range (outMax <= outMin): Shows \"invalid output range\" (red), no output.  \r\n- Invalid input (non-numeric): Shows \"invalid input\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `inMin set to 0.00`, `clamp set to true`), blue for output (e.g., `out: 50.00, in: 75.00`), \r\nred for errors, yellow for unknown context."},{"id":"3bd2b1028a03c3a0","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"200","payloadType":"num","x":130,"y":1260,"wires":[["585a2a5143cdc7f4","4585b59e227a62f7"]]},{"id":"7c30b7519b322ccf","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual Clamp","rules":[{"t":"set","p":"context","pt":"msg","to":"clamp","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":330,"y":1300,"wires":[["585a2a5143cdc7f4","4585b59e227a62f7"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"047e0cba096016cf","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"false","payloadType":"bool","x":130,"y":1300,"wires":[["7c30b7519b322ccf"]]},{"id":"d593f1e616d95e3a","type":"function","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Tick Tock","func":"// Initialize state from context, with defaults\nlet period = context.get(\"period\") ?? 10;\nlet intervalId = context.get(\"intervalId\") ?? null;\nlet state = context.get(\"state\") ?? true;\nlet cleanupRegistered = context.get(\"cleanupRegistered\") ?? false;\n\n// Ensure minimum period\nperiod = Math.max(1, period);\ncontext.set(\"period\", period);\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"period\":\n            let value = Number(msg.payload);\n            if (isNaN(value) || value <= 0) {\n                node.warn(`Invalid period value: ${msg.payload} (must be a positive number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid period\" });\n                return null;\n            }\n            period = value;\n            context.set(\"period\", period);\n            node.status({ fill: \"green\", shape: \"dot\", text: `period set to ${period}s` });\n            if (intervalId) {\n                // Restart with new period\n                clearInterval(intervalId);\n                state = true;\n                const halfPeriodMs = (period * 1000) / 2;\n                node.send({ payload: state });\n                intervalId = setInterval(() => {\n                    state = !state;\n                    context.set(\"state\", state);\n                    node.send({ payload: state });\n                }, halfPeriodMs);\n                context.set(\"intervalId\", intervalId);\n                node.status({ fill: \"green\", shape: \"dot\", text: `started, period: ${period}s` });\n            }\n            break;\n        case \"command\":\n            if (typeof msg.payload !== \"string\") {\n                node.warn(`Invalid command value: ${msg.payload} (must be \"start\" or \"stop\")`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid command\" });\n                return null;\n            }\n            if (msg.payload === \"start\" && !intervalId) {\n                // Start the square wave\n                state = true;\n                const halfPeriodMs = (period * 1000) / 2;\n                node.send({ payload: state });\n                intervalId = setInterval(() => {\n                    state = !state;\n                    context.set(\"state\", state);\n                    node.send({ payload: state });\n                }, halfPeriodMs);\n                context.set(\"intervalId\", intervalId);\n                node.status({ fill: \"green\", shape: \"dot\", text: `started, period: ${period}s` });\n            } else if (msg.payload === \"stop\" && intervalId) {\n                // Stop the square wave\n                clearInterval(intervalId);\n                intervalId = null;\n                context.set(\"intervalId\", null);\n                node.status({ fill: \"red\", shape: \"dot\", text: \"stopped\" });\n            } else {\n                node.warn(`Invalid or ignored command: ${msg.payload} (use \"start\" or \"stop\")`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid command\" });\n                return null;\n            }\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    return null;\n}\n\n// Cleanup on node close\nif (!cleanupRegistered) {\n    node.on(\"close\", () => {\n        if (intervalId) {\n            clearInterval(intervalId);\n            context.set(\"intervalId\", null);\n        }\n    });\n    cleanupRegistered = true;\n    context.set(\"cleanupRegistered\", true);\n}\n\n// No action for non-config messages\nreturn null;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2780,"y":1100,"wires":[["01dd5a0291ee34bf"]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Generates a square wave output toggling between true and false.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"period\", \"command\").  \r\n: payload (number | string) : Numeric value for period, string (\"start\" or \"stop\") for command.\r\n\r\n### Outputs\r\n: 1 (boolean) : Square wave value (true or false).\r\n\r\n### Details\r\nGenerates a square wave output toggling between `true` and `false` every half `period` (seconds). \r\nConfigure via `msg.context = \"period\"` (positive number) to set the period, or `\"command\"` (\"start\" or \"stop\") \r\nto control the wave. Starts outputting immediately on \"start\" and toggles at each half-period. Stops on \"stop\" or node close. \r\nInvalid configurations are rejected. Use in automation for periodic switching or timing.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid period (non-numeric, non-positive): Shows \"invalid period\" (red), no output.  \r\n- Invalid command (not \"start\" or \"stop\"): Shows \"invalid command\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `period set to 10.00`, `started, period: 10.00`), blue for output (e.g., `out: true`), \r\nred for stop or errors, yellow for unknown context."},{"id":"1c4a0c6ac11182fb","type":"inject","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Inject Flow","props":[{"p":"context","v":"command","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"start","payloadType":"str","x":2410,"y":1100,"wires":[["d593f1e616d95e3a","1f5fbfa83de44f17"]]},{"id":"01dd5a0291ee34bf","type":"debug","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"debug 19","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3020,"y":1100,"wires":[]},{"id":"05914194efba4838","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Load Sequence","func":"// Initialize state from context, with defaults\nlet enable = context.get(\"enable\") ?? true;\nlet hysteresis = context.get(\"hysteresis\") ?? 0.5;\n\nlet threshold1 = context.get(\"threshold1\") ?? 10.0;\nlet threshold2 = context.get(\"threshold2\") ?? 20.0;\nlet threshold3 = context.get(\"threshold3\") ?? 30.0;\nlet threshold4 = context.get(\"threshold4\") ?? 40.0;\n\nlet feedback1 = context.get(\"feedback1\") ?? false;\nlet feedback2 = context.get(\"feedback2\") ?? false;\nlet feedback3 = context.get(\"feedback3\") ?? false;\nlet feedback4 = context.get(\"feedback4\") ?? false;\n\nlet out1 = context.get(\"out1\") ?? false;\nlet out2 = context.get(\"out2\") ?? false;\nlet out3 = context.get(\"out3\") ?? false;\nlet out4 = context.get(\"out4\") ?? false;\n\nlet dOn = context.get(\"dOn\") ?? 0;\nlet lastInput = context.get(\"lastInput\") ?? 0;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return [null, null, null, null];\n    }\n    switch (msg.context) {\n        case \"enable\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid enable value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid enable\" });\n                return [null, null, null, null];\n            }\n            enable = msg.payload;\n            context.set(\"enable\", enable);\n            node.status({ fill: \"green\", shape: \"dot\", text: `enable set to ${enable}` });\n            break;\n        case \"hysteresis\":\n            let hystValue = Number(msg.payload);\n            if (isNaN(hystValue) || hystValue < 0) {\n                node.warn(`Invalid hysteresis value: ${msg.payload} (must be a non-negative number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid hysteresis\" });\n                return [null, null, null, null];\n            }\n            hysteresis = hystValue;\n            context.set(\"hysteresis\", hysteresis);\n            node.status({ fill: \"green\", shape: \"dot\", text: `hysteresis set to ${hysteresis.toFixed(2)}` });\n            break;\n        case \"threshold1\":\n        case \"threshold2\":\n        case \"threshold3\":\n        case \"threshold4\":\n            let threshValue = Number(msg.payload);\n            if (isNaN(threshValue)) {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return [null, null, null, null];\n            }\n            if (msg.context === \"threshold1\") threshold1 = threshValue;\n            else if (msg.context === \"threshold2\") threshold2 = threshValue;\n            else if (msg.context === \"threshold3\") threshold3 = threshValue;\n            else threshold4 = threshValue;\n            // Validate thresholds\n            if (threshold1 >= threshold2 || threshold2 >= threshold3 || threshold3 >= threshold4) {\n                node.warn(`Invalid threshold order: threshold1 (${threshold1}) < threshold2 (${threshold2}) < threshold3 (${threshold3}) < threshold4 (${threshold4}) required`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid threshold order\" });\n                return [null, null, null, null];\n            }\n            context.set(msg.context, threshValue);\n            node.status({ fill: \"green\", shape: \"dot\", text: `${msg.context} set to ${threshValue.toFixed(2)}` });\n            break;\n        case \"feedback1\":\n        case \"feedback2\":\n        case \"feedback3\":\n        case \"feedback4\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return [null, null, null, null];\n            }\n            if (msg.context === \"feedback1\") feedback1 = msg.payload;\n            else if (msg.context === \"feedback2\") feedback2 = msg.payload;\n            else if (msg.context === \"feedback3\") feedback3 = msg.payload;\n            else feedback4 = msg.payload;\n            context.set(msg.context, msg.payload);\n            node.status({ fill: \"green\", shape: \"dot\", text: `${msg.context} set to ${msg.payload}` });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return [null, null, null, null];\n    }\n    // Use last input for config messages\n    let inputValue = lastInput;\n    // Process logic\n    let newMsg = processLogic(inputValue);\n    return newMsg;\n}\n\n// Handle non-config inputs\nlet inputValue;\nif (msg.payload === \"kill\") {\n    inputValue = lastInput; // No change to inputValue for kill\n} else {\n    inputValue = Number(msg.payload);\n    if (isNaN(inputValue)) {\n        node.warn(`Invalid input: ${msg.payload} (must be a number or \"kill\")`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n        return [null, null, null, null];\n    }\n    lastInput = inputValue;\n    context.set(\"lastInput\", lastInput);\n}\n\n// Kill switch\nif (msg.payload === \"kill\") {\n    out1 = out2 = out3 = out4 = false;\n    dOn = 0;\n    context.set(\"out1\", out1);\n    context.set(\"out2\", out2);\n    context.set(\"out3\", out3);\n    context.set(\"out4\", out4);\n    context.set(\"dOn\", dOn);\n    node.status({ fill: \"red\", shape: \"dot\", text: \"kill: all outputs off\" });\n    return [{ payload: false }, { payload: false }, { payload: false }, { payload: false }];\n}\n\n// Validate thresholds\nif (threshold1 >= threshold2 || threshold2 >= threshold3 || threshold3 >= threshold4) {\n    node.warn(`Invalid threshold order: threshold1 (${threshold1}) < threshold2 (${threshold2}) < threshold3 (${threshold3}) < threshold4 (${threshold4}) required`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid threshold order\" });\n    return [null, null, null, null];\n}\n\n// Process logic\nfunction processLogic(inputValue) {\n    let newMsg = [null, null, null, null];\n    let numStagesOn = 0;\n\n    if (!enable) {\n        if (out4) {\n            out4 = false;\n            newMsg[3] = { payload: false };\n        } else if (out3) {\n            out3 = false;\n            newMsg[2] = { payload: false };\n        } else if (out2) {\n            out2 = false;\n            newMsg[1] = { payload: false };\n        } else if (out1) {\n            out1 = false;\n            newMsg[0] = { payload: false };\n        }\n        numStagesOn = 0;\n    } else {\n        let newOut1 = out1;\n        let newOut2 = out2;\n        let newOut3 = out3;\n        let newOut4 = out4;\n\n        // Output 1\n        if (out1) {\n            if (inputValue < (threshold1 - hysteresis) && (feedback1 && !out2)) {\n                newOut1 = false;\n            }\n        } else if (inputValue >= threshold1) {\n            newOut1 = true;\n        }\n\n        // Output 2\n        if (out2) {\n            if (inputValue < (threshold2 - hysteresis) && (feedback2 && !out3)) {\n                newOut2 = false;\n            }\n        } else if (inputValue >= threshold2 && feedback1) {\n            newOut2 = true;\n        }\n\n        // Output 3\n        if (out3) {\n            if (inputValue < (threshold3 - hysteresis) && (feedback3 && !out4)) {\n                newOut3 = false;\n            }\n        } else if (inputValue >= threshold3 && feedback2) {\n            newOut3 = true;\n        }\n\n        // Output 4\n        if (out4) {\n            if (inputValue < (threshold4 - hysteresis) && feedback4) {\n                newOut4 = false;\n            }\n        } else if (inputValue >= threshold4 && feedback3) {\n            newOut4 = true;\n        }\n\n        // Prioritize highest stage change\n        if (newOut4 !== out4) {\n            out4 = newOut4;\n            newMsg = [null, null, null, { payload: out4 }];\n        } else if (newOut3 !== out3) {\n            out3 = newOut3;\n            newMsg = [null, null, { payload: out3 }, null];\n        } else if (newOut2 !== out2) {\n            out2 = newOut2;\n            newMsg = [null, { payload: out2 }, null, null];\n        } else if (newOut1 !== out1) {\n            out1 = newOut1;\n            newMsg = [{ payload: out1 }, null, null, null];\n        }\n\n        numStagesOn = (out1 ? 1 : 0) + (out2 ? 1 : 0) + (out3 ? 1 : 0) + (out4 ? 1 : 0);\n    }\n\n    // Update state\n    dOn = numStagesOn;\n    context.set(\"out1\", out1);\n    context.set(\"out2\", out2);\n    context.set(\"out3\", out3);\n    context.set(\"out4\", out4);\n    context.set(\"dOn\", dOn);\n\n    // Set status\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `out: [${out1}, ${out2}, ${out3}, ${out4}], in: ${inputValue.toFixed(2)}`\n    });\n\n    return newMsg;\n}\n\n// Call processLogic for non-kill inputs\nlet newMsg = processLogic(inputValue);\nreturn newMsg;","outputs":4,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":1460,"wires":[[],[],[],[]],"inputLabels":["input"],"outputLabels":["load1","load2","load3","load4"],"icon":"font-awesome/fa-wrench","info":"Sequences four boolean outputs based on input thresholds with feedback and hysteresis.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"enable\", \"hysteresis\", \"threshold1-4\", \"feedback1-4\").  \r\n: payload (number | string | boolean) : Number for input, \"kill\" to shut down, boolean for enable/feedback1-4, \r\nnumber for hysteresis/threshold1-4.\r\n\r\n### Outputs\r\n: 1-4 (boolean) : Output states (out1 to out4), true when active.\r\n\r\n### Details\r\nSequences four outputs (`out1` to `out4`) based on a numeric input (`msg.payload`) crossing thresholds \r\n(`threshold1` to `threshold4`), with hysteresis and feedback (`feedback1` to `feedback4`). \r\nOutputs turn on when input exceeds a threshold and required feedback is present (e.g., `out2` requires `feedback1`). \r\nOutputs turn off when input falls below `thresholdX - hysteresis` and higher-stage feedback allows. \r\nConfigure via `msg.context = \"enable\"` (boolean), `hysteresis` (non-negative number), `threshold1-4` (numbers, increasing order), \r\n`feedback1-4` (booleans). `msg.payload = \"kill\"` shuts down all outputs. `enable=false` disables outputs sequentially. \r\nTracks active stages (`dOn`). Invalid inputs or configurations are rejected. Use in automation for staged load control.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid enable/feedback1-4 (non-boolean): Shows \"invalid enable\" (red), no output.  \r\n- Invalid hysteresis (non-numeric, negative): Shows \"invalid hysteresis\" (red), no output.  \r\n- Invalid threshold1-4 (non-numeric): Shows \"invalid thresholdX\" (red), no output.  \r\n- Invalid threshold order (threshold1 >= threshold2, etc.): Shows \"invalid threshold order\" (red), no output.  \r\n- Invalid input (non-numeric, not \"kill\"): Shows \"invalid input\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `threshold1 set to 10.00`), blue for output (e.g., `out: [true, false, false, false], in: 15.00`), \r\nred for kill or errors, yellow for unknown context."},{"id":"3bbce6c5a475c58f","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"60","payloadType":"num","x":130,"y":1460,"wires":[["05914194efba4838","6dd8aaf5258dce71"]]},{"id":"b49fd5c481848e2d","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual Feedback1","rules":[{"t":"set","p":"context","pt":"msg","to":"feedback1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":240,"y":1520,"wires":[["05914194efba4838","6dd8aaf5258dce71"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"fedae56fa515c26b","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual Feedback2","rules":[{"t":"set","p":"context","pt":"msg","to":"feedback2","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":260,"y":1560,"wires":[["05914194efba4838","6dd8aaf5258dce71"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"c3e8143a97a15e6c","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual Feedback3","rules":[{"t":"set","p":"context","pt":"msg","to":"feedback3","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":280,"y":1600,"wires":[["05914194efba4838","6dd8aaf5258dce71"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"41d5f95b9654733a","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual Feedback4","rules":[{"t":"set","p":"context","pt":"msg","to":"feedback4","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":300,"y":1640,"wires":[["05914194efba4838","6dd8aaf5258dce71"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"88a6bf234551bdb8","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Latch","func":"let prevState = context.get(\"prevState\") || false;\nlet timeoutId = context.get(\"timeoutId\"); // Retrieve the timeout ID from context\n\nlet delayOn = 5000;  // Delay when turning ON\nlet delayOff = 5000; // Delay when turning OFF\n\n// If state changes from false to true\nif (!prevState && msg.payload === true) {\n    context.set(\"prevState\", true);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: true };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the first output after delay\n    }, delayOn);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n// If state changes from true to false\nelse if (prevState && msg.payload === false) {\n    context.set(\"prevState\", false);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: false };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the second output after delay\n    }, delayOff);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":810,"y":1500,"wires":[["b49fd5c481848e2d"]]},{"id":"0333dc50b1d77108","type":"function","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"Delay","func":"// Initialize state\nlet prevState = context.get(\"prevState\") ?? false;\nlet timeoutId = context.get(\"timeoutId\");\nlet delayOn = context.get(\"delayOn\") ?? (this.delayOn ? Number(this.delayOn) : 1000); // Default 1000ms\nlet delayOff = context.get(\"delayOff\") ?? (this.delayOff ? Number(this.delayOff) : 1000); // Default 1000ms\n\n// Handle configuration\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"reset\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid reset value: ${msg.payload}`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid reset\" });\n                return null;\n            }\n            if (msg.payload === true) {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                    context.set(\"timeoutId\", timeoutId);\n                }\n                prevState = false;\n                context.set(\"prevState\", prevState);\n                node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n                return null;\n            }\n            return null;\n        case \"delayOn\":\n            let newDelayOn = Number(msg.payload);\n            if (isNaN(newDelayOn) || newDelayOn < 0) {\n                node.warn(`Invalid delayOn: ${msg.payload} (must be a non-negative number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid delayOn\" });\n                return null;\n            }\n            delayOn = newDelayOn;\n            context.set(\"delayOn\", delayOn);\n            node.status({ fill: \"green\", shape: \"dot\", text: `delayOn set: ${delayOn}` });\n            return null;\n        case \"delayOff\":\n            let newDelayOff = Number(msg.payload);\n            if (isNaN(newDelayOff) || newDelayOff < 0) {\n                node.warn(`Invalid delayOff: ${msg.payload} (must be a non-negative number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid delayOff\" });\n                return null;\n            }\n            delayOff = newDelayOff;\n            context.set(\"delayOff\", delayOff);\n            node.status({ fill: \"green\", shape: \"dot\", text: `delayOff set: ${delayOff}` });\n            return null;\n        default:\n            node.warn(`Unrecognized context: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// Process input\nif (msg.payload === undefined || typeof msg.payload !== \"boolean\") {\n    node.warn(`Invalid input: ${msg.payload} (must be boolean)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Update status for input\nnode.status({ fill: \"blue\", shape: \"ring\", text: `in: ${msg.payload}, awaiting delay` });\n\n// Handle state transitions\nif (!prevState && msg.payload === true) {\n    prevState = true;\n    context.set(\"prevState\", prevState);\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: true };\n        node.send(newMsg); // Send to single output\n        node.status({ fill: \"blue\", shape: \"dot\", text: `out: true, in: ${msg.payload}` });\n    }, delayOn);\n    context.set(\"timeoutId\", timeoutId);\n} else if (prevState && msg.payload === false) {\n    prevState = false;\n    context.set(\"prevState\", prevState);\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: false };\n        node.send(newMsg); // Send to single output\n        node.status({ fill: \"blue\", shape: \"dot\", text: `out: false, in: ${msg.payload}` });\n    }, delayOff);\n    context.set(\"timeoutId\", timeoutId);\n}\n\nreturn null;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2830,"y":820,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Delays boolean input with configurable on/off delays.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear state, \"delayOn\" to set on delay, \"delayOff\" to set off delay).  \r\n: payload (boolean | number) : Boolean for state change, number for delay configuration.\r\n\r\n### Outputs\r\n: 1 (boolean) : True after delayOn ms on false-to-true transition, false after delayOff ms on true-to-false transition.\r\n\r\n### Details\r\nDelays `msg.payload` (boolean). Sends `true` after `delayOn` ms on false-to-true transition, `false` after `delayOff` \r\nms on true-to-false transition. Configure delays via `delayOn` and `delayOff` properties, `msg.context = \"delayOn\"`, \r\nor `msg.context = \"delayOff\"` with `msg.payload` as a non-negative number. Reset state via `msg.context = \"reset\"` \r\nwith `msg.payload = true`. Invalid inputs or config are rejected.\r\n\r\n### Properties\r\n: delayOn (number) : Delay for true output (ms, default: 1000, minimum: 0).  \r\n: delayOff (number) : Delay for false output (ms, default: 1000, minimum: 0).\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for `msg.context`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-boolean): Shows \"invalid input\" (red), no output.  \r\n- Invalid reset value (non-boolean): Shows \"invalid reset\" (red), no output.  \r\n- Invalid delayOn or delayOff (non-numeric, negative): Shows \"invalid delayOn\" or \"invalid delayOff\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (red), no output.  \r\n\r\nStatus: green for config (e.g., `state reset`, `delayOn set: 1000`), blue for input (e.g., `in: true`) \r\nand output (e.g., `out: true, in: true`), red for errors."},{"id":"434f10270db2ac1e","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Latch","func":"let prevState = context.get(\"prevState\") || false;\nlet timeoutId = context.get(\"timeoutId\"); // Retrieve the timeout ID from context\n\nlet delayOn = 5000;  // Delay when turning ON\nlet delayOff = 5000; // Delay when turning OFF\n\n// If state changes from false to true\nif (!prevState && msg.payload === true) {\n    context.set(\"prevState\", true);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: true };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the first output after delay\n    }, delayOn);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n// If state changes from true to false\nelse if (prevState && msg.payload === false) {\n    context.set(\"prevState\", false);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: false };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the second output after delay\n    }, delayOff);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":850,"y":1540,"wires":[["fedae56fa515c26b"]]},{"id":"106b4dbbf5f7e8f2","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Latch","func":"let prevState = context.get(\"prevState\") || false;\nlet timeoutId = context.get(\"timeoutId\"); // Retrieve the timeout ID from context\n\nlet delayOn = 5000;  // Delay when turning ON\nlet delayOff = 5000; // Delay when turning OFF\n\n// If state changes from false to true\nif (!prevState && msg.payload === true) {\n    context.set(\"prevState\", true);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: true };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the first output after delay\n    }, delayOn);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n// If state changes from true to false\nelse if (prevState && msg.payload === false) {\n    context.set(\"prevState\", false);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: false };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the second output after delay\n    }, delayOff);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":870,"y":1580,"wires":[["c3e8143a97a15e6c"]]},{"id":"f198ab0461517005","type":"function","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Latch","func":"let prevState = context.get(\"prevState\") || false;\nlet timeoutId = context.get(\"timeoutId\"); // Retrieve the timeout ID from context\n\nlet delayOn = 5000;  // Delay when turning ON\nlet delayOff = 5000; // Delay when turning OFF\n\n// If state changes from false to true\nif (!prevState && msg.payload === true) {\n    context.set(\"prevState\", true);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: true };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the first output after delay\n    }, delayOn);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n// If state changes from true to false\nelse if (prevState && msg.payload === false) {\n    context.set(\"prevState\", false);\n\n    // If there's an existing timeout, cancel it\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n\n    // Set a new timeout\n    timeoutId = setTimeout(() => {\n        let newMsg = { ...msg, payload: false };  // Copy message and modify payload\n        node.send(newMsg);  // Send to the second output after delay\n    }, delayOff);\n    context.set(\"timeoutId\", timeoutId); // Save the timeout ID to context\n}\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":890,"y":1620,"wires":[["41d5f95b9654733a"]]},{"id":"408bf47a4e15bf5e","type":"inject","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"Execute","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"Your Payload","payloadType":"str","x":140,"y":220,"wires":[["d7fac52daac0072c","fbe110868dbb4ad8"]]},{"id":"33703438e0b4ad7e","type":"inject","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"Reset","props":[{"p":"context","v":"reset","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":130,"y":280,"wires":[["d7fac52daac0072c","fbe110868dbb4ad8"]]},{"id":"c969c1bce8bc327b","type":"debug","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"debug 28","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":940,"y":200,"wires":[]},{"id":"bb50a79ad1278a40","type":"debug","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"debug 29","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":1000,"y":240,"wires":[]},{"id":"35cb85789fdae36b","type":"debug","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"debug 30","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":1060,"y":280,"wires":[]},{"id":"47d5f326953d211d","type":"change","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"To False","rules":[{"t":"set","p":"payload","pt":"msg","to":"false","tot":"bool"}],"action":"","property":"","from":"","to":"","reg":false,"x":820,"y":320,"wires":[["c969c1bce8bc327b","bb50a79ad1278a40","35cb85789fdae36b"]]},{"id":"e00f0bddbbe2d81d","type":"function","z":"1d6822e3b60ba374","g":"5f70baf7384cf6e3","name":"Compare","func":"// Initialize setpoint from context, default to 50\nconst setpoint = context.get(\"setpoint\") ?? 50;\n\n// Handle setpoint update\nif (msg.context === 'setpoint') {\n    if (typeof msg.payload === 'number' && !isNaN(msg.payload)) {\n        context.set('setpoint', msg.payload);\n        node.status({ fill: \"green\", shape: \"dot\", text: `setpoint: ${msg.payload}` });\n        return null;\n    } else {\n        node.warn(`Invalid setpoint: ${msg.payload} (must be a number)`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"invalid setpoint\" });\n        return null;\n    }\n}\n\n// Validate input\nif (msg.payload === undefined || typeof msg.payload !== 'number' || isNaN(msg.payload)) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Compare input to setpoint\nconst cv = msg.payload;\nlet output;\nif (cv < setpoint) {\n    output = [{ payload: false }, { payload: false }, { payload: true }];\n} else if (cv === setpoint) {\n    output = [{ payload: false }, { payload: true }, { payload: false }];\n} else {\n    output = [{ payload: true }, { payload: false }, { payload: false }];\n}\n\n// Set status\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `in: ${cv.toFixed(2)}, sp: ${setpoint}, out: [${output.map(o => o.payload)}]`\n});\n\nreturn output;","outputs":3,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1740,"y":660,"wires":[[],[],[]],"inputLabels":["in"],"outputLabels":["greater than","equal","less than"],"icon":"font-awesome/fa-wrench","info":"Compares a number input to a stored setpoint, outputting three boolean signals.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"setpoint\" to update setpoint value).  \r\n: payload (number) : Input number to compare, or setpoint value if `context = \"setpoint\"`.\r\n\r\n### Outputs\r\n1. Greater than\r\n: payload (boolean) : True if input > setpoint, else false.\r\n2. Equal to\r\n: payload (boolean) : True if input = setpoint, else false.\r\n3. Less than\r\n: payload (boolean) : True if input < setpoint, else false.\r\n\r\n### Details\r\nThe COMPARE Block is a Sedona-inspired node for control systems, comparing `msg.payload` (a number) to a stored `setpoint` (default: 50). \r\n\r\nIt outputs three messages indicating if the input is greater than, equal to, or less than the setpoint. Set the setpoint via `msg.context = \"setpoint\"` with `msg.payload` as a number (e.g., `msg.payload = 60`).\r\n\r\nOutputs are new messages (`{ payload: boolean }`) sent to three ports in order: greater, equal, less. Invalid inputs or setpoint values are rejected with warnings. Use in automation workflows for condition monitoring or control logic.\r\n\r\n### Error Handling\r\n- Invalid input (undefined, non-number, NaN): Shows \"invalid input\" (red), no output.  \r\n- Invalid setpoint (non-number, NaN): Shows \"invalid setpoint\" (red), no output.  \r\n\r\nStatus shows green for setpoint updates (e.g., `setpoint: 60`), blue for output (e.g., `cv: 55, sp: 50, out: [true, false, false]`), red for errors."},{"id":"4fd0b55f30005e8c","type":"function","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Sine Wave","func":"// Initialize state from context, with defaults\nlet lastExecution = context.get(\"lastExecution\") ?? Date.now();\nlet phase = context.get(\"phase\") ?? 0;\nlet lowerLimit = context.get(\"lowerLimit\") ?? 0;\nlet upperLimit = context.get(\"upperLimit\") ?? 100;\nlet period = context.get(\"period\") ?? 10;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    let value = Number(msg.payload);\n    if (isNaN(value)) {\n        node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n        node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n        return null;\n    }\n    switch (msg.context) {\n        case \"lowerLimit\":\n            lowerLimit = value;\n            if (lowerLimit > upperLimit) {\n                upperLimit = lowerLimit;\n                context.set(\"upperLimit\", upperLimit);\n                node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set to ${lowerLimit.toFixed(2)}, upperLimit adjusted to ${upperLimit.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `lowerLimit set to ${lowerLimit.toFixed(2)}` });\n            }\n            context.set(\"lowerLimit\", lowerLimit);\n            break;\n        case \"upperLimit\":\n            upperLimit = value;\n            if (upperLimit < lowerLimit) {\n                lowerLimit = upperLimit;\n                context.set(\"lowerLimit\", lowerLimit);\n                node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set to ${upperLimit.toFixed(2)}, lowerLimit adjusted to ${lowerLimit.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `upperLimit set to ${upperLimit.toFixed(2)}` });\n            }\n            context.set(\"upperLimit\", upperLimit);\n            break;\n        case \"period\":\n            if (value <= 0) {\n                node.warn(`Invalid period value: ${msg.payload} (must be positive)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid period\" });\n                return null;\n            }\n            period = value;\n            context.set(\"period\", period);\n            node.status({ fill: \"green\", shape: \"dot\", text: `period set to ${period.toFixed(2)}` });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    return null; // Stop processing after configuration update\n}\n\n// Calculate time difference\nlet now = Date.now();\nlet deltaTime = (now - lastExecution) / 1000; // Convert ms to seconds\nlastExecution = now;\ncontext.set(\"lastExecution\", lastExecution);\n\n// Reset to lower limit if period is zero\nif (period <= 0) {\n    let newMsg = { payload: lowerLimit };\n    node.status({ fill: \"blue\", shape: \"dot\", text: `out: ${lowerLimit.toFixed(2)}, phase: ${phase.toFixed(2)}` });\n    return newMsg;\n}\n\n// Compute phase shift\nphase = (phase + deltaTime / period) % 1;\ncontext.set(\"phase\", phase);\n\n// Sine wave calculation (normalized between -1 and 1)\nlet sineValue = Math.sin(2 * Math.PI * phase);\n\n// Scale sine wave to the specified range\nlet amplitude = upperLimit - lowerLimit;\nlet value = lowerLimit + (sineValue + 1) * amplitude / 2;\n\nlet newMsg = { payload: value };\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${value.toFixed(2)}, phase: ${phase.toFixed(2)}`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2790,"y":920,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Generates a sine wave output scaled to a configurable range.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"lowerLimit\", \"upperLimit\", \"period\").  \r\n: payload (number) : Config value for lowerLimit/upperLimit/period.\r\n\r\n### Outputs\r\n: 1 (number) : Sine wave value scaled between lowerLimit and upperLimit.\r\n\r\n### Details\r\nGenerates a sine wave output based on time, scaled between `lowerLimit` and `upperLimit` over a `period` (seconds). \r\nTracks phase (0 to 1) to maintain continuity. Configure via `msg.context = \"lowerLimit\"`, `\"upperLimit\"`, `\"period\"` \r\nwith numeric values. Ensures `upperLimit ≥ lowerLimit` by adjusting the other value if needed. Returns `lowerLimit` \r\nif `period ≤ 0`. Invalid configurations are rejected. Use in automation for testing or signal generation.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid lowerLimit/upperLimit/period (non-numeric): Shows \"invalid lowerLimit\" (red), no output.  \r\n- Invalid period (non-positive for sine wave): Shows \"invalid period\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `lowerLimit set to 0.00`, `upperLimit set to 100.00, lowerLimit adjusted to 50.00`), \r\nblue for output (e.g., `out: 50.00, phase: 0.25`), red for errors, yellow for unknown context."},{"id":"b3160a2542fdf2ab","type":"random","z":"1d6822e3b60ba374","g":"5f70baf7384cf6e3","name":"","low":"0","high":"100","inte":"false","property":"payload","x":1540,"y":660,"wires":[["b8aa1d6417dcf221","e00f0bddbbe2d81d","25fa803e81f75335"]]},{"id":"cc0268e860b78df5","type":"inject","z":"1d6822e3b60ba374","g":"5f70baf7384cf6e3","name":"Inject Flow","props":[],"repeat":"5","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":1370,"y":660,"wires":[["b3160a2542fdf2ab"]]},{"id":"b8aa1d6417dcf221","type":"debug","z":"1d6822e3b60ba374","g":"5f70baf7384cf6e3","name":"debug 38","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":1740,"y":740,"wires":[]},{"id":"4ab42ce8fe612377","type":"inject","z":"1d6822e3b60ba374","g":"5f70baf7384cf6e3","name":"Default","props":[{"p":"context","v":"setpoint","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"50","payloadType":"num","x":1530,"y":600,"wires":[["e00f0bddbbe2d81d","25fa803e81f75335"]]},{"id":"30b202a2583316d8","type":"trigger","z":"1d6822e3b60ba374","g":"9df534ffc2085145","name":"OneShot","op1":"1","op2":"0","op1type":"str","op2type":"str","duration":"250","extend":false,"overrideDelay":false,"units":"ms","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":1340,"y":860,"wires":[["e49aec2f4e76487a"]]},{"id":"e49aec2f4e76487a","type":"trigger","z":"1d6822e3b60ba374","g":"9df534ffc2085145","name":"OneShot","op1":"1","op2":"0","op1type":"str","op2type":"str","duration":"250","extend":false,"overrideDelay":false,"units":"ms","reset":"","bytopic":"all","topic":"topic","outputs":1,"x":2060,"y":860,"wires":[[]]},{"id":"51b333a737aa829f","type":"function","z":"1d6822e3b60ba374","g":"463764c52c5452a5","name":"Tstat","func":"// Initialize state from context, with defaults\nlet setpoint = context.get(\"setpoint\") ?? 70;\nlet diff = context.get(\"diff\") ?? 2;\nlet isHeating = context.get(\"isHeating\") ?? false;\nlet above = context.get(\"above\") ?? false;\nlet below = context.get(\"below\") ?? false;\nlet lastInput = context.get(\"lastInput\") ?? 0;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"setpoint\":\n            let spValue = Number(msg.payload);\n            if (isNaN(spValue)) {\n                node.warn(`Invalid setpoint value: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid setpoint\" });\n                return null;\n            }\n            setpoint = spValue;\n            context.set(\"setpoint\", setpoint);\n            node.status({ fill: \"green\", shape: \"dot\", text: `setpoint set to ${setpoint.toFixed(2)}` });\n            break;\n        case \"diff\":\n            let diffValue = Number(msg.payload);\n            if (isNaN(diffValue) || diffValue < 0) {\n                node.warn(`Invalid diff value: ${msg.payload} (must be a non-negative number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid diff\" });\n                return null;\n            }\n            diff = diffValue;\n            context.set(\"diff\", diff);\n            node.status({ fill: \"green\", shape: \"dot\", text: `diff set to ${diff.toFixed(2)}` });\n            break;\n        case \"isHeating\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid isHeating value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid isHeating\" });\n                return null;\n            }\n            isHeating = msg.payload;\n            context.set(\"isHeating\", isHeating);\n            node.status({ fill: \"green\", shape: \"dot\", text: `isHeating set to ${isHeating}` });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    return null; // Stop processing after configuration update\n}\n\n// Process input\nlet input = Number(msg.payload);\nif (isNaN(input)) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Cache input\nlastInput = input;\ncontext.set(\"lastInput\", lastInput);\n\n// Thermostat logic\nlet delta = diff / 2;\nlet hiValue = setpoint + delta;\nlet loValue = setpoint - delta;\n\nif (input > hiValue) {\n    above = true;\n    below = false;\n} else if (input < loValue) {\n    above = false;\n    below = true;\n} else if (above && input < setpoint) {\n    above = false;\n} else if (below && input > setpoint) {\n    below = false;\n}\n\n// Persist state\ncontext.set(\"above\", above);\ncontext.set(\"below\", below);\n\n// Set output\nlet newMsg = [\n    { payload: isHeating },\n    { payload: above },\n    { payload: below }\n];\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: [${isHeating ? \"heating\" : \"cooling\"}, ${above}, ${below}], in: ${input.toFixed(2)}, sp: ${setpoint.toFixed(2)}`\n});\n\nreturn newMsg;","outputs":3,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":3350,"y":920,"wires":[[],[],[]],"inputLabels":["input"],"outputLabels":["isHeating","above","below"],"icon":"font-awesome/fa-wrench","info":"Thermostat controller for heating/cooling with setpoint and differential.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"setpoint\", \"diff\", \"isHeating\").  \r\n: payload (number | boolean) : Numeric input for temperature or config value for setpoint/diff, boolean for isHeating.\r\n\r\n### Outputs\r\n: 1 (boolean) : isHeating (true for heating, false for cooling).  \r\n: 2 (boolean) : Above setpoint + diff/2 state.  \r\n: 3 (boolean) : Below setpoint - diff/2 state.\r\n\r\n### Details\r\nCompares a numeric input (`msg.payload`) to a setpoint (`setpoint`) with a differential (`diff`) to control heating/cooling. \r\nSets `above` when input > `setpoint + diff/2`, `below` when input < `setpoint - diff/2`. Clears `above` when input < `setpoint`, \r\nclears `below` when input > `setpoint`. Configures via `msg.context = \"setpoint\"` (number), `\"diff\"` (non-negative number), \r\n`\"isHeating\"` (boolean). Outputs three booleans: `isHeating`, `above`, `below`. Invalid inputs or configurations are rejected. \r\nUse in automation for thermostat control.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid setpoint (non-numeric): Shows \"invalid setpoint\" (red), no output.  \r\n- Invalid diff (non-numeric, negative): Shows \"invalid diff\" (red), no output.  \r\n- Invalid isHeating (non-boolean): Shows \"invalid isHeating\" (red), no output.  \r\n- Invalid input (non-numeric): Shows \"invalid input\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `setpoint set to 70.00`), blue for output \r\n(e.g., `out: [heating, false, true], in: 65.00, sp: 70.00`), red for errors, yellow for unknown context."},{"id":"16f1421947a4ec0d","type":"function","z":"1d6822e3b60ba374","g":"229300b1beb9bf03","name":"Frequency","func":"// Initialize state from context, with defaults\nlet lastIn = context.get(\"lastIn\") ?? false;\nlet lastEdge = context.get(\"lastEdge\") ?? 0;\nlet completeCycle = context.get(\"completeCycle\") ?? false;\nlet ppm = context.get(\"ppm\") ?? 0;\nlet pph = context.get(\"pph\") ?? 0;\nlet ppd = context.get(\"ppd\") ?? 0;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    switch (msg.context) {\n        case \"reset\":\n            // Reset state\n            lastIn = false;\n            lastEdge = 0;\n            completeCycle = false;\n            ppm = 0;\n            pph = 0;\n            ppd = 0;\n            context.set(\"lastIn\", lastIn);\n            context.set(\"lastEdge\", lastEdge);\n            context.set(\"completeCycle\", completeCycle);\n            context.set(\"ppm\", ppm);\n            context.set(\"pph\", pph);\n            context.set(\"ppd\", ppd);\n            node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            break;\n    }\n    return null;\n}\n\n// Process input\nif (msg.payload === undefined || typeof msg.payload !== \"boolean\") {\n    node.warn(`Invalid input: ${msg.payload} (must be boolean)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Initialize output\nlet output = { ppm, pph, ppd };\n\n// Detect rising edge\nif (msg.payload && !lastIn) { // Rising edge: true and lastIn was false\n    let now = Date.now();\n    if (!completeCycle) {\n        completeCycle = true;\n    } else {\n        // Compute period in minutes\n        let periodMs = now - lastEdge;\n        let periodMin = periodMs / 60000;\n        if (periodMin !== 0) {\n            output.ppm = 1 / periodMin; // Pulses per minute\n            output.pph = output.ppm * 60; // Pulses per hour\n            output.ppd = output.ppm * 1440; // Pulses per day\n\n            context.set(\"ppm\", output.ppm);\n            context.set(\"pph\", output.pph);\n            context.set(\"ppd\", output.ppd);\n        }\n    }\n    lastEdge = now;\n    context.set(\"lastEdge\", lastEdge);\n    context.set(\"completeCycle\", completeCycle);\n}\n\n// Update lastIn\nlastIn = msg.payload;\ncontext.set(\"lastIn\", lastIn);\n\n// Set output\nmsg.payload = output;\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `ppm: ${output.ppm.toFixed(2)}, pph: ${output.pph.toFixed(2)}, ppd: ${output.ppd.toFixed(2)}`\n});\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1770,"y":1820,"wires":[[]],"inputLabels":["input"],"outputLabels":["stats"],"icon":"font-awesome/fa-wrench","info":"Measures pulse frequency from boolean rising edges.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"reset\" to clear state).  \r\n: payload (boolean) : Input boolean to detect rising edges.\r\n\r\n### Outputs\r\n: payload (object) : Pulse rates { ppm, pph, ppd } (pulses per minute, hour, day). (a new message is output)\r\n\r\n### Details\r\nThe FREQUENCY Block is a Sedona-inspired node for control systems, measuring pulse frequency from rising edges in `msg.payload` (boolean, e.g., `true` for pulse). \r\n\r\nIt outputs an object with pulse rates: `ppm` (pulses per minute), `pph` (per hour), and `ppd` (per day). \r\n\r\nReset state via `msg.context = \"reset\"`.\r\n\r\nInvalid inputs or config values are rejected with warnings.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-boolean, e.g., `\"true\"`, `1`): Shows \"invalid input\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus shows green for config (e.g., `state reset`), blue for output (e.g., `out: 1.00 ppm, in: true`), red/yellow for errors."},{"id":"f0fcdaf9afb2594f","type":"function","z":"1d6822e3b60ba374","g":"9df534ffc2085145","name":"PID","func":"// Retrieve context variables with defaults using ??\nlet run = context.get(\"run\") ?? true;\nlet kp = context.get(\"kp\") ?? 0;\nlet ki = context.get(\"ki\") ?? 0;\nlet kd = context.get(\"kd\") ?? 0;\nlet setpoint = context.get(\"setpoint\") ?? 0;\nlet deadband = context.get(\"deadband\") ?? 0;\nlet dbBehavior = context.get(\"dbBehavior\") ?? \"HoldLastResult\"; // \"ReturnToZero\" or \"HoldLastResult\"\nlet outMin = context.get(\"outMin\") ?? -Infinity;\nlet outMax = context.get(\"outMax\") ?? Infinity;\nlet maxChange = context.get(\"maxChange\") ?? 0;\nlet directAction = context.get(\"directAction\") ?? false;\nlet errorSum = context.get(\"errorSum\") ?? 0;\nlet lastError = context.get(\"lastError\") ?? 0;\nlet result = context.get(\"result\") ?? 0;\nlet storekp = context.get(\"storekp\") ?? 0;\nlet storeki = context.get(\"storeki\") ?? 0;\nlet storemin = context.get(\"storemin\") ?? -Infinity;\nlet storemax = context.get(\"storemax\") ?? Infinity;\nlet kpkiConst = context.get(\"kpkiConst\") ?? 0;\nlet minInt = context.get(\"minInt\") ?? 0;\nlet maxInt = context.get(\"maxInt\") ?? 0;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    switch (msg.context) {\n        case \"setpoint\":\n            context.set(\"setpoint\", msg.payload);\n        case \"kp\":\n            context.set(\"kp\", msg.payload);\n            break;\n        case \"ki\":\n            context.set(\"ki\", msg.payload);\n            break;\n        case \"kd\":\n            context.set(\"kd\", msg.payload);\n            break;\n        case \"run\":\n            context.set(\"run\", msg.payload);\n            break;\n        case \"deadband\":\n            context.set(\"deadband\", msg.payload);\n            break;\n        case \"dbBehavior\":\n            context.set(\"dbBehavior\", msg.payload); // \"ReturnToZero\" or \"HoldLastResult\"\n            break;\n        case \"outMin\":\n            context.set(\"outMin\", msg.payload);\n            break;\n        case \"outMax\":\n            context.set(\"outMax\", msg.payload);\n            break;\n        case \"maxChange\":\n            context.set(\"maxChange\", msg.payload);\n            break;\n        case \"directAction\":\n            context.set(\"directAction\", msg.payload);\n            break;\n        default:\n            // Ignore unrecognized context properties\n            break;\n    }\n    return null; // Stop processing after setting a setpoint\n}\n\n// PID Calculation\nlet input = msg.payload;\nlet interval = msg.interval ?? 0.01; // Default to 0.01s if not provided\n\n// Checks\nif (!run || interval <= 0 || kp === 0) {\n    msg.payload = 0;\n    return msg;\n}\n\n// Deadband check\nif (deadband !== 0 && input <= setpoint + deadband && input >= setpoint - deadband) {\n    msg.payload = (dbBehavior === \"ReturnToZero\") ? 0 : result;\n    return msg;\n}\n\n// Update internal constraints if config changes\nif (kp !== storekp || ki !== storeki || outMin !== storemin || outMax !== storemax) {\n    if (kp !== storekp && kp !== 0 && storekp !== 0) {\n        errorSum = errorSum * storekp / kp;\n    }\n    if (ki !== storeki && ki !== 0 && storeki !== 0) {\n        errorSum = errorSum * storeki / ki;\n    }\n    kpkiConst = kp * ki;\n    if (kpkiConst === 0) {\n        minInt = 0;\n        maxInt = 0;\n    } else {\n        minInt = outMin * kpkiConst;\n        maxInt = outMax * kpkiConst;\n    }\n    storekp = kp;\n    storeki = ki;\n    storemin = outMin;\n    storemax = outMax;\n    context.set(\"storekp\", storekp);\n    context.set(\"storeki\", storeki);\n    context.set(\"storemin\", storemin);\n    context.set(\"storemax\", storemax);\n    context.set(\"kpkiConst\", kpkiConst);\n    context.set(\"minInt\", minInt);\n    context.set(\"maxInt\", maxInt);\n}\n\n// Calculate error\nlet error = setpoint - input;\nif (ki !== 0) {\n    errorSum += interval * error;\n    if (directAction) {\n        if (-errorSum > maxInt) errorSum = -maxInt;\n        else if (-errorSum < minInt) errorSum = -minInt;\n    } else {\n        errorSum = Math.min(Math.max(errorSum, minInt), maxInt);\n    }\n    context.set(\"errorSum\", errorSum);\n}\n\n// Gain calculations\nlet fps = Math.max(1 / Math.max(interval, 1e-6), 1); // Frames per second, avoid division by zero\nlet pGain = kp * error;\nlet intGain = kp * ki * errorSum / fps;\nlet dGain = (kd !== 0) ? kp * kd * (error - lastError) / interval : 0;\n\ncontext.set(\"lastError\", error);\n\nlet pv = pGain + intGain + dGain;\nif (directAction) pv = -pv;\npv = Math.min(Math.max(pv, outMin), outMax);\n\n// Apply maxChange limit\nif (maxChange !== 0) {\n    if (result > pv) {\n        result = (result - pv > maxChange) ? result - maxChange : pv;\n    } else {\n        result = (pv - result > maxChange) ? result + maxChange : pv;\n    }\n} else {\n    result = pv;\n}\n\ncontext.set(\"result\", result);\nmsg.payload = result;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2050,"y":940,"wires":[[]]},{"id":"e31a4fe9ee481443","type":"function","z":"1d6822e3b60ba374","g":"f2f049190ff39eb1","name":"Interpolate","func":"// Initialize points from context, default to a simple 2-point table\nlet points = context.get(\"points\") ?? [\n    { x: 0, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    if (msg.context === \"points\") {\n        // Expect payload as array of {x, y} objects\n        if (Array.isArray(msg.payload) && msg.payload.length >= 2 &&\n            msg.payload.every(p => typeof p.x === \"number\" && !isNaN(p.x) &&\n                typeof p.y === \"number\" && !isNaN(p.y))) {\n            points = msg.payload;\n            context.set(\"points\", points);\n            node.status({ fill: \"green\", shape: \"dot\", text: `points: ${msg.payload.length}` });\n        } else {\n            node.warn(`Invalid points value: must be array of {x, y} objects with ≥2 points`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"invalid points\" });\n        }\n    } else {\n        node.warn(`Unrecognized context property: ${msg.context}`);\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n    }\n    return null;\n}\n\n// Process input\nconst input = Number(msg.payload);\nif (msg.payload === undefined || isNaN(input)) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number or numeric string)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Linear interpolation\nlet output = NaN; // Default to NaN if out of range\nconst isPositiveSlope = points.length >= 2 && points[1].x > points[0].x;\n\nif (points.length >= 2) {\n    for (let i = 0; i < points.length - 1; i++) {\n        let x1 = points[i].x, y1 = points[i].y;\n        let x2 = points[i + 1].x, y2 = points[i + 1].y;\n        if (isPositiveSlope ? (input >= x1 && input <= x2) : (input <= x1 && input >= x2)) {\n            let m = (y2 - y1) / (x2 - x1);\n            let b = y1 - (m * x1);\n            output = (m * input) + b;\n            break;\n        }\n    }\n}\n\n// Set output\nif (isNaN(output)) {\n    node.warn(`Input out of range: ${input}`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"input out of range\" });\n    return null;\n}\nmsg.payload = output;\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `in: ${input.toFixed(2)}, out: ${msg.payload.toFixed(2)}`\n});\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1770,"y":1640,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Linearly interpolates a number input using a configurable points table.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"points\" to update {x, y} table).  \r\n: payload (number | string) : Input number or numeric string to interpolate, or points array for config.\r\n\r\n### Outputs\r\n: payload (number) : Interpolated output value. (the existing message is modified and output)\r\n\r\n### Details\r\nThe INTERPOLATE Block is a Sedona-inspired node for control systems, interpolating `msg.payload` (a number or numeric string, e.g., `50`, `\"50\"`) using a table of `{x, y}` points (default: `[{x: 0, y: 0}, {x: 100, y: 100}]`). \r\n\r\nSet points via `msg.context = \"points\"` with `msg.payload` as an array of `{x, y}` objects (≥2 points, e.g., `[{x: 0, y: 0}, {x: 50, y: 100}]`).\r\n\r\nInvalid inputs, config values, or out-of-range inputs are rejected with warnings.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, e.g., `\"abc\"`, `null`): Shows \"invalid input\" (red), no output.  \r\n- Invalid points (non-array, less than 2 points, invalid {x, y}): Shows \"invalid points\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n- Input out of range: Shows \"input out of range\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `points: 2`), blue for output (e.g., `out: 50.00, in: 50.00`), red/yellow for errors."},{"id":"6ae6562bf83d8b7f","type":"function","z":"1d6822e3b60ba374","g":"f19a608dd6e58fd2","name":"Max","func":"// Initialize max from context, default to 0 if undefined\nlet max = context.get(\"max\") ?? 50;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (msg.hasOwnProperty(\"payload\")) {\n        switch (msg.context) {\n            case \"max\":\n                if (typeof msg.payload === \"number\" && !isNaN(msg.payload)) {\n                    context.set(\"max\", msg.payload);\n                    node.status({ fill: \"green\", shape: \"dot\", text: `max set to ${msg.payload}` });\n                } else {\n                    node.warn(`Invalid max value: ${msg.payload}`);\n                }\n                break;\n            case \"setpoint\":\n                if (typeof msg.payload === \"number\" && !isNaN(msg.payload)) {\n                    context.set(\"max\", msg.payload);\n                    node.status({ fill: \"green\", shape: \"dot\", text: `setpoint set to ${msg.payload}` });\n                } else {\n                    node.warn(`Invalid setpoint value: ${msg.payload}`);\n                }\n                break;\n            default:\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                break;\n        }\n    } else {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n    }\n    return null; // Stop processing after configuration update\n}\n\n// Process input\nlet input = Number(msg.payload);\nif (isNaN(input)) {\n    node.warn(`Invalid input: ${msg.payload}`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null; // Drop invalid inputs\n}\n\n// Cap input at max\nmsg.payload = input < max ? input : max;\nnode.status({ fill: \"blue\", shape: \"dot\", text: `in: ${input.toFixed(2)}, out:${msg.payload.toFixed(2)}` });\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1750,"y":1220,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Caps a number input at a configurable maximum value.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"max\" or \"setpoint\" to update maximum).  \r\n: payload (number | string) : Input number or numeric string to cap, or maximum value for config.\r\n\r\n### Outputs\r\n: payload (number) : Input capped at maximum value. (the existing message is modified and output)\r\n\r\n### Details\r\nThe MAX Block is a Sedona-inspired node for control systems, capping `msg.payload` (a number or numeric string, e.g., `55`, `\"55\"`) to a maximum (`max`, default: 50). \r\n\r\nSet the maximum via `msg.context = \"max\"` or `msg.context = \"setpoint\"` (alias) with `msg.payload` as a number or numeric string (e.g., `msg.payload = \"60\"`).\r\n\r\nInvalid inputs or config values are rejected with warnings.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, e.g., `\"abc\"`, `null`): Shows \"invalid input\" (red), no output.  \r\n- Invalid maximum (non-numeric, e.g., `\"abc\"`, `null`): Shows \"invalid max\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus shows green for config (e.g., `max: 60.00`), blue for output (e.g., `out: 50.00, in: 55.00`), red/yellow for errors."},{"id":"8887bd675ef9b7bd","type":"function","z":"1d6822e3b60ba374","g":"b5acac16791836bb","name":"MinMax","func":"// Initialize state from context, with defaults\nlet min = context.get(\"min\") ?? 0;\nlet max = context.get(\"max\") ?? 100;\nlet lastInput = context.get(\"lastInput\") ?? 0;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    let value = Number(msg.payload);\n    if (isNaN(value)) {\n        node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n        node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n        return null;\n    }\n    switch (msg.context) {\n        case \"min\":\n            min = value;\n            if (min > max) {\n                max = min;\n                context.set(\"max\", max);\n                node.status({ fill: \"green\", shape: \"dot\", text: `min set to ${min.toFixed(2)}, max adjusted to ${max.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `min set to ${min.toFixed(2)}` });\n            }\n            context.set(\"min\", min);\n            break;\n        case \"max\":\n            max = value;\n            if (max < min) {\n                min = max;\n                context.set(\"min\", min);\n                node.status({ fill: \"green\", shape: \"dot\", text: `max set to ${max.toFixed(2)}, min adjusted to ${min.toFixed(2)}` });\n            } else {\n                node.status({ fill: \"green\", shape: \"dot\", text: `max set to ${max.toFixed(2)}` });\n            }\n            context.set(\"max\", max);\n            break;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n    // No recalculation for config updates\n    return null;\n}\n\n// Process input\nlet input = Number(msg.payload);\nif (isNaN(input)) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\n// Cache input\nlastInput = input;\ncontext.set(\"lastInput\", lastInput);\n\n// Clamp input to [min, max]\nlet output = Math.min(Math.max(input, min), max);\nlet newMsg = { payload: output };\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `out: ${output.toFixed(2)}, in: ${input.toFixed(2)}`\n});\n\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2780,"y":1280,"wires":[["f39cc230dd2a699e"]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Clamps a numeric input to a configurable range.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"min\", \"max\").  \r\n: payload (number) : Input value to clamp or config value for min/max.\r\n\r\n### Outputs\r\n: 1 (number) : Clamped input value within [min, max].\r\n\r\n### Details\r\nClamps a numeric input (`msg.payload`) to a range defined by `min` and `max`. Configure via `msg.context = \"min\"` or `\"max\"` with numeric values. Ensures `min ≤ max` by adjusting the other value if needed (e.g., setting `min > max` updates `max` to `min`). Invalid inputs or configurations are rejected. Use in automation to limit signal values.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid min/max (non-numeric): Shows \"invalid min\" (red), no output.  \r\n- Invalid input (non-numeric): Shows \"invalid input\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `min set to 0.00`, `max set to 100.00, min adjusted to 50.00`), blue for output (e.g., `out: 50.00, in: 75.00`), red for errors, yellow for unknown context."},{"id":"b6fea3faddbde77d","type":"function","z":"1d6822e3b60ba374","g":"9df534ffc2085145","name":"PID_EXP","func":"// Initialize state from context, with defaults\nlet run = context.get(\"run\") ?? true;\nlet kp = context.get(\"kp\") ?? 0;\nlet ki = context.get(\"ki\") ?? 0;\nlet kd = context.get(\"kd\") ?? 0;\nlet setpoint = context.get(\"setpoint\") ?? 0;\nlet deadband = context.get(\"deadband\") ?? 0;\nlet dbBehavior = context.get(\"dbBehavior\") ?? \"ReturnToZero\";\nlet outMin = context.get(\"outMin\") ?? -Infinity;\nlet outMax = context.get(\"outMax\") ?? Infinity;\nlet maxChange = context.get(\"maxChange\") ?? 0;\nlet directAction = context.get(\"directAction\") ?? false;\nlet errorSum = context.get(\"errorSum\") ?? 0;\nlet lastError = context.get(\"lastError\") ?? 0;\nlet lastDError = context.get(\"lastDError\") ?? 0;\nlet result = context.get(\"result\") ?? 0;\nlet storekp = context.get(\"storekp\") ?? 0;\nlet storeki = context.get(\"storeki\") ?? 0;\nlet storemin = context.get(\"storemin\") ?? -Infinity;\nlet storemax = context.get(\"storemax\") ?? Infinity;\nlet kpkiConst = context.get(\"kpkiConst\") ?? 0;\nlet minInt = context.get(\"minInt\") ?? 0;\nlet maxInt = context.get(\"maxInt\") ?? 0;\nlet lastTime = context.get(\"lastTime\") ?? Date.now();\nlet tuneMode = context.get(\"tuneMode\") ?? false;\nlet tuneData = context.get(\"tuneData\") ?? { oscillations: [], lastPeak: null, lastTrough: null, Ku: 0, Tu: 0 };\n\n// Handle configuration updates and special commands\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"setpoint\":\n        case \"kp\":\n        case \"ki\":\n        case \"kd\":\n        case \"deadband\":\n        case \"outMin\":\n        case \"outMax\":\n        case \"maxChange\":\n            let value = Number(msg.payload);\n            if (isNaN(value)) {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if ((msg.context === \"deadband\" || msg.context === \"maxChange\") && value < 0) {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be non-negative)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if (msg.context === \"setpoint\") setpoint = value;\n            else if (msg.context === \"kp\") kp = value;\n            else if (msg.context === \"ki\") ki = value;\n            else if (msg.context === \"kd\") kd = value;\n            else if (msg.context === \"deadband\") deadband = value;\n            else if (msg.context === \"outMin\") outMin = value;\n            else if (msg.context === \"outMax\") outMax = value;\n            else maxChange = value;\n            // Validate outMax > outMin\n            if ((msg.context === \"outMin\" || msg.context === \"outMax\") && outMax <= outMin) {\n                node.warn(`Invalid output range: outMax (${outMax}) must be greater than outMin (${outMin})`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid output range\" });\n                return null;\n            }\n            context.set(msg.context, value);\n            node.status({ fill: \"green\", shape: \"dot\", text: `${msg.context} set to ${value.toFixed(2)}` });\n            if (msg.context === \"setpoint\") return null; // Stop after setpoint change\n            break;\n        case \"run\":\n        case \"directAction\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if (msg.context === \"run\") run = msg.payload;\n            else directAction = msg.payload;\n            context.set(msg.context, msg.payload);\n            node.status({ fill: \"green\", shape: \"dot\", text: `${msg.context} set to ${msg.payload}` });\n            break;\n        case \"dbBehavior\":\n            if (msg.payload !== \"ReturnToZero\" && msg.payload !== \"HoldLastResult\") {\n                node.warn(`Invalid dbBehavior value: ${msg.payload} (must be \"ReturnToZero\" or \"HoldLastResult\")`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid dbBehavior\" });\n                return null;\n            }\n            dbBehavior = msg.payload;\n            context.set(\"dbBehavior\", dbBehavior);\n            node.status({ fill: \"green\", shape: \"dot\", text: `dbBehavior set to ${dbBehavior}` });\n            break;\n        case \"reset\":\n            errorSum = 0;\n            lastError = 0;\n            lastDError = 0;\n            result = 0;\n            tuneMode = false;\n            tuneData = { oscillations: [], lastPeak: null, lastTrough: null, Ku: 0, Tu: 0 };\n            context.set(\"errorSum\", errorSum);\n            context.set(\"lastError\", lastError);\n            context.set(\"lastDError\", lastDError);\n            context.set(\"result\", result);\n            context.set(\"tuneMode\", tuneMode);\n            context.set(\"tuneData\", tuneData);\n            node.status({ fill: \"red\", shape: \"dot\", text: \"reset: state cleared\" });\n            return null;\n        case \"tune\":\n            let tuneKp = Number(msg.payload) || 1;\n            if (isNaN(tuneKp)) {\n                node.warn(`Invalid tune kp value: ${msg.payload} (must be a number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid tune kp\" });\n                return null;\n            }\n            tuneMode = true;\n            kp = tuneKp;\n            ki = 0;\n            kd = 0;\n            tuneData = { oscillations: [], lastPeak: null, lastTrough: null, Ku: 0, Tu: 0 };\n            context.set(\"tuneMode\", tuneMode);\n            context.set(\"kp\", kp);\n            context.set(\"ki\", ki);\n            context.set(\"kd\", kd);\n            context.set(\"tuneData\", tuneData);\n            node.status({ fill: \"red\", shape: \"dot\", text: `tune: started with kp=${tuneKp.toFixed(2)}` });\n            return null;\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// PID Calculation\nlet input = Number(msg.payload);\nif (isNaN(input)) {\n    node.warn(`Invalid input: ${msg.payload} (must be a number)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null;\n}\n\nlet currentTime = Date.now();\nlet interval = (currentTime - lastTime) / 1000; // Seconds\ncontext.set(\"lastTime\", currentTime);\n\nif (!run || interval <= 0 || kp === 0) {\n    let newMsg = { payload: 0 };\n    node.status({ fill: \"blue\", shape: \"dot\", text: `out: 0.00, in: ${input.toFixed(2)}, setpoint: ${setpoint.toFixed(2)}` });\n    return newMsg;\n}\n\n// Deadband check\nif (deadband !== 0 && input <= setpoint + deadband && input >= setpoint - deadband) {\n    let newMsg = { payload: dbBehavior === \"ReturnToZero\" ? 0 : result };\n    node.status({ fill: \"blue\", shape: \"dot\", text: `out: ${newMsg.payload.toFixed(2)}, in: ${input.toFixed(2)}, setpoint: ${setpoint.toFixed(2)}` });\n    return newMsg;\n}\n\n// Update internal constraints\nif (kp !== storekp || ki !== storeki || outMin !== storemin || outMax !== storemax) {\n    if (kp !== storekp && kp !== 0 && storekp !== 0) {\n        errorSum = errorSum * storekp / kp;\n    }\n    if (ki !== storeki && ki !== 0 && storeki !== 0) {\n        errorSum = errorSum * storeki / ki;\n    }\n    kpkiConst = kp * ki;\n    minInt = kpkiConst === 0 ? 0 : outMin * kpkiConst;\n    maxInt = kpkiConst === 0 ? 0 : outMax * kpkiConst;\n    storekp = kp;\n    storeki = ki;\n    storemin = outMin;\n    storemax = outMax;\n    context.set(\"storekp\", storekp);\n    context.set(\"storeki\", storeki);\n    context.set(\"storemin\", storemin);\n    context.set(\"storemax\", storemax);\n    context.set(\"kpkiConst\", kpkiConst);\n    context.set(\"minInt\", minInt);\n    context.set(\"maxInt\", maxInt);\n}\n\n// Calculate error\nlet error = setpoint - input;\n\n// Tuning assistant (Ziegler-Nichols)\nif (tuneMode) {\n    let td = tuneData;\n    if (lastError > 0 && error <= 0) { // Peak detected\n        if (td.lastPeak !== null) {\n            td.oscillations.push({ time: currentTime, amplitude: td.lastPeak });\n        }\n        td.lastPeak = lastError;\n    } else if (lastError < 0 && error >= 0) { // Trough detected\n        td.lastTrough = lastError;\n    }\n    if (td.oscillations.length >= 3) { // Enough data to tune\n        let periodSum = 0;\n        for (let i = 1; i < td.oscillations.length; i++) {\n            periodSum += (td.oscillations[i].time - td.oscillations[i-1].time) / 1000;\n        }\n        td.Tu = periodSum / (td.oscillations.length - 1); // Average period in seconds\n        td.Ku = kp; // Ultimate gain\n        // Ziegler-Nichols PID tuning (classic)\n        kp = 0.6 * td.Ku;\n        ki = 2 * kp / td.Tu;\n        kd = kp * td.Tu / 8;\n        context.set(\"kp\", kp);\n        context.set(\"ki\", ki);\n        context.set(\"kd\", kd);\n        context.set(\"tuneMode\", false);\n        let newMsg = {\n            payload: result,\n            tuneResult: { Kp: kp, Ki: ki, Kd: kd, Ku: td.Ku, Tu: td.Tu }\n        };\n        context.set(\"tuneData\", td);\n        node.status({ fill: \"green\", shape: \"dot\", text: `tune: completed, Kp=${kp.toFixed(2)}, Ki=${ki.toFixed(2)}, Kd=${kd.toFixed(2)}` });\n        return newMsg;\n    }\n    context.set(\"tuneData\", td);\n}\n\n// Integral term\nif (ki !== 0) {\n    errorSum += interval * error;\n    if (directAction) {\n        if (-errorSum > maxInt) errorSum = -maxInt;\n        else if (-errorSum < minInt) errorSum = -minInt;\n    } else {\n        errorSum = Math.min(Math.max(errorSum, minInt), maxInt);\n    }\n    context.set(\"errorSum\", errorSum);\n}\n\n// Gain calculations\nlet pGain = kp * error;\nlet intGain = ki !== 0 ? kp * ki * errorSum * interval : 0;\nlet dRaw = (error - lastError) / interval;\nlet dFiltered = kd !== 0 ? 0.1 * dRaw + 0.9 * lastDError : 0;\nlet dGain = kd !== 0 ? kp * kd * dFiltered : 0;\n\ncontext.set(\"lastError\", error);\ncontext.set(\"lastDError\", dFiltered);\n\n// Output calculation\nlet pv = pGain + intGain + dGain;\nif (directAction) pv = -pv;\npv = Math.min(Math.max(pv, outMin), outMax);\n\n// Rate of change limit\nif (maxChange !== 0) {\n    if (result > pv) {\n        result = (result - pv > maxChange) ? result - maxChange : pv;\n    } else {\n        result = (pv - result > maxChange) ? result + maxChange : pv;\n    }\n} else {\n    result = pv;\n}\n\ncontext.set(\"result\", result);\nlet newMsg = {\n    payload: result,\n    diagnostics: { pGain, intGain, dGain, error, errorSum }\n};\nnode.status({ fill: \"blue\", shape: \"dot\", text: `out: ${result.toFixed(2)}, in: ${input.toFixed(2)}, setpoint: ${setpoint.toFixed(2)}` });\nreturn newMsg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2060,"y":1020,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Implements a PID controller with deadband, output limits, and tuning.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"setpoint\", \"kp\", \"ki\", \"kd\", \"run\", \"deadband\", \"dbBehavior\", \"outMin\", \"outMax\", \r\n\"maxChange\", \"directAction\", \"reset\", \"tune\").  \r\n: payload (number | boolean | string) : Number for input/setpoint/kp/ki/kd/deadband/outMin/outMax/maxChange/tune kp, \r\nboolean for run/directAction, string for dbBehavior (\"ReturnToZero\" or \"HoldLastResult\").\r\n\r\n### Outputs\r\n: 1 (number) : PID control output, with diagnostics and optional tuneResult.\r\n\r\n### Details\r\nCalculates a PID control output based on a numeric input (`msg.payload`), setpoint, and gains (`kp`, `ki`, `kd`). \r\nSupports deadband (`deadband`, `dbBehavior`), output limits (`outMin`, `outMax`), rate of change limit (`maxChange`), \r\ndirect/reverse action (`directAction`), and integral clamping. Configure via `msg.context` with numbers, booleans, or strings. \r\nSpecial commands: `reset` (clears state), `tune` (Ziegler-Nichols tuning). Outputs diagnostics \r\n(`pGain`, `intGain`, `dGain`, `error`, `errorSum`) and tuning results (`Kp`, `Ki`, `Kd`, `Ku`, `Tu`). \r\nInvalid inputs or configurations are rejected. Use in automation for precise control.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid setpoint/kp/ki/kd/deadband/outMin/outMax/maxChange/tune kp (non-numeric): Shows \"invalid setpoint\" (red), no output.  \r\n- Invalid deadband/maxChange (negative): Shows \"invalid deadband\" (red), no output.  \r\n- Invalid run/directAction (non-boolean): Shows \"invalid run\" (red), no output.  \r\n- Invalid dbBehavior (not \"ReturnToZero\" or \"HoldLastResult\"): Shows \"invalid dbBehavior\" (red), no output.  \r\n- Invalid output range (outMax <= outMin): Shows \"invalid output range\" (red), no output.  \r\n- Invalid input (non-numeric): Shows \"invalid input\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `setpoint set to 50.00`, `tune: completed`), blue for output \r\n(e.g., `out: 50.00, in: 25.00, setpoint: 50.00`), red for reset/tune start or errors, yellow for unknown context."},{"id":"943a00f3adf7e893","type":"random","z":"1d6822e3b60ba374","g":"f19a608dd6e58fd2","name":"","low":"10","high":"100","inte":"false","property":"payload","x":1580,"y":1220,"wires":[["6ae6562bf83d8b7f","27cf3190d7fc2d97"]]},{"id":"ed450bbe96f08cf4","type":"inject","z":"1d6822e3b60ba374","g":"f19a608dd6e58fd2","name":"Inject Flow","props":[],"repeat":"5","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":1370,"y":1220,"wires":[["943a00f3adf7e893"]]},{"id":"7150b086e9c0fc1c","type":"function","z":"1d6822e3b60ba374","g":"5360543001f5b360","name":"Min","func":"// Initialize min from context, default to 0 if undefined\nlet min = context.get(\"min\") ?? 50;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (msg.hasOwnProperty(\"payload\")) {\n        switch (msg.context) {\n            case \"min\":\n                if (typeof msg.payload === \"number\" && !isNaN(msg.payload)) {\n                    context.set(\"min\", msg.payload);\n                    node.status({ fill: \"green\", shape: \"dot\", text: `min set to ${msg.payload}` });\n                } else {\n                    node.warn(`Invalid min value: ${msg.payload}`);\n                }\n                break;\n            case \"setpoint\":\n                if (typeof msg.payload === \"number\" && !isNaN(msg.payload)) {\n                    context.set(\"min\", msg.payload);\n                    node.status({ fill: \"green\", shape: \"dot\", text: `min set to ${msg.payload}` });\n                } else {\n                    node.warn(`Invalid setpoint value: ${msg.payload}`);\n                }\n                break;\n            default:\n                node.warn(`Unrecognized context property: ${msg.context}`);\n                break;\n        }\n    } else {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n    }\n    return null; // Stop processing after configuration update\n}\n\n// Process input\nlet input = Number(msg.payload);\nif (isNaN(input)) {\n    node.warn(`Invalid input: ${msg.payload}`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid input\" });\n    return null; // Drop invalid inputs\n}\n\n// Cap input at min\nmsg.payload = input > min ? input : min;\nnode.status({ fill: \"blue\", shape: \"dot\", text: `in: ${input.toFixed(2)}, out: ${msg.payload.toFixed(2)}` });\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1750,"y":1400,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Ensures a number input is at least a configurable minimum value.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"min\" or \"setpoint\" to update minimum).  \r\n: payload (number | string) : Input number or numeric string to enforce, or minimum value for config.\r\n\r\n### Outputs\r\n: payload (number) : Input enforced at minimum value. (the existing message is modified and output)\r\n\r\n### Details\r\nThe MIN Block is a Sedona-inspired node for control systems, ensuring `msg.payload` (a number or numeric string, e.g., `45`, `\"45\"`) is at least a minimum (`min`, default: 50). Set the minimum via `msg.context = \"min\"` or `msg.context = \"setpoint\"` (alias) with `msg.payload` as a number or numeric string (e.g., `msg.payload = \"40\"`).\r\n\r\nInvalid inputs or config values are rejected with warnings.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid input (undefined, non-numeric, e.g., `\"abc\"`, `null`): Shows \"invalid input\" (red), no output.  \r\n- Invalid minimum (non-numeric, e.g., `\"abc\"`, `null`): Shows \"invalid min\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus shows green for config (e.g., `min: 40.00`), blue for output (e.g., `out: 50.00, in: 45.00`), red/yellow for errors."},{"id":"db56798dfc406b65","type":"random","z":"1d6822e3b60ba374","g":"5360543001f5b360","name":"","low":"10","high":"100","inte":"false","property":"payload","x":1580,"y":1400,"wires":[["7150b086e9c0fc1c","134508812af2d793"]]},{"id":"817b0cca8243cb51","type":"inject","z":"1d6822e3b60ba374","g":"5360543001f5b360","name":"Inject Flow","props":[],"repeat":"5","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":1370,"y":1400,"wires":[["db56798dfc406b65"]]},{"id":"099ac74de27cb650","type":"inject","z":"1d6822e3b60ba374","g":"f2f049190ff39eb1","name":"Inject Flow","props":[{"p":"context","v":"points","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"[{\"x\":0,\"y\":0},{\"x\":70,\"y\":50},{\"x\":100,\"y\":100}]","payloadType":"json","x":1570,"y":1580,"wires":[["e31a4fe9ee481443","4fc22d124d27b12c"]]},{"id":"158de9a6957ad5d0","type":"random","z":"1d6822e3b60ba374","g":"f2f049190ff39eb1","name":"","low":"10","high":"100","inte":"false","property":"payload","x":1580,"y":1620,"wires":[["e31a4fe9ee481443","4fc22d124d27b12c"]]},{"id":"1dd0d7953417b881","type":"inject","z":"1d6822e3b60ba374","g":"f2f049190ff39eb1","name":"Inject Flow","props":[],"repeat":"5","crontab":"","once":true,"onceDelay":"0.2","topic":"","x":1370,"y":1620,"wires":[["158de9a6957ad5d0"]]},{"id":"6a846461605aad4d","type":"random","z":"1d6822e3b60ba374","g":"b5acac16791836bb","name":"","low":"-200","high":"200","inte":"false","property":"payload","x":2600,"y":1280,"wires":[["8887bd675ef9b7bd","cbd77dbeb3caa24f"]]},{"id":"cdf88b5420cc0fbd","type":"inject","z":"1d6822e3b60ba374","g":"b5acac16791836bb","name":"Inject Flow","props":[],"repeat":"5","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":2410,"y":1280,"wires":[["6a846461605aad4d"]]},{"id":"379a50304242e0da","type":"inject","z":"1d6822e3b60ba374","g":"229300b1beb9bf03","name":"Boolean Toggle","props":[{"p":"payload"}],"repeat":"5","crontab":"","once":true,"onceDelay":"0.1","topic":"","payload":"true","payloadType":"bool","x":1390,"y":1820,"wires":[["16f1421947a4ec0d","60b33f32a00511a0"]]},{"id":"c9b756f9902d023c","type":"inject","z":"1d6822e3b60ba374","g":"229300b1beb9bf03","name":"Boolean Toggle","props":[{"p":"payload"}],"repeat":"5","crontab":"","once":true,"onceDelay":"0.4","topic":"","payload":"false","payloadType":"bool","x":1470,"y":1860,"wires":[["16f1421947a4ec0d","60b33f32a00511a0"]]},{"id":"2f4f2c1e3aabe1e3","type":"debug","z":"1d6822e3b60ba374","g":"463764c52c5452a5","name":"debug 45","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3640,"y":980,"wires":[]},{"id":"cd727ef12158e609","type":"debug","z":"1d6822e3b60ba374","g":"463764c52c5452a5","name":"debug 46","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3640,"y":1040,"wires":[]},{"id":"d7fac52daac0072c","type":"function","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"TimeSequence","func":"// Initialize state from context, with defaults\nlet delay = context.get(\"delay\") ?? 5000;\nlet stage = context.get(\"stage\") ?? 0;\nlet timer = context.get(\"timer\") ?? null;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    switch (msg.context) {\n        case \"delay\":\n            if (!msg.hasOwnProperty(\"payload\")) {\n                node.warn(\"Configuration update ignored: msg.payload missing\");\n                node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n                return null;\n            }\n            const delayValue = Number(msg.payload);\n            if (!isNaN(delayValue) && delayValue >= 0) {\n                delay = delayValue;\n                context.set(\"delay\", delay);\n                node.status({ fill: \"green\", shape: \"dot\", text: `delay: ${delay.toFixed(0)} ms` });\n            } else {\n                node.warn(`Invalid delay value: ${msg.payload} (must be a non-negative number or numeric string)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid delay\" });\n            }\n            break;\n        case \"reset\":\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n                context.set(\"timer\", timer);\n            }\n            stage = 0;\n            context.set(\"stage\", stage);\n            // Send false to all outputs\n            const resetMsg = { payload: false };\n            node.status({ fill: \"green\", shape: \"dot\", text: \"state reset\" });\n            return [resetMsg, resetMsg, resetMsg, resetMsg];\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"red\", shape: \"ring\", text: \"unknown context\" });\n            break;\n    }\n    return null;\n}\n\nif (!msg.hasOwnProperty(\"payload\")) {\n    node.warn(\"Configuration update ignored: msg.payload missing\");\n    node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n    return null;\n}\n\n// Process input\nif (stage !== 0) {\n    node.status({ fill: \"yellow\", shape: \"ring\", text: \"sequence running\" });\n    return null;\n}\n\n// Start new sequence\nstage = 1;\ncontext.set(\"stage\", stage);\n\n// Clone msg for output\nconst cloneMsg = RED.util.cloneMessage(msg);\n\n// Output sequence\nconst sendNextOutput = () => {\n    if (stage === 0) return; // Stop if reset\n    const stageLabels = [\"stage 1\", \"stage 2\", \"stage 3\", \"reset\"];\n    const outputs = [null, null, null, null];\n    outputs[stage - 1] = cloneMsg; // Set message for current stage\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `out: ${stageLabels[stage - 1]}, in: ${JSON.stringify(cloneMsg.payload).slice(0, 20)}`\n    });\n    node.send(outputs);\n\n    stage++;\n    if (stage <= 4) {\n        timer = setTimeout(sendNextOutput, delay);\n        context.set(\"timer\", timer);\n    } else {\n        stage = 0; // Sequence complete\n        timer = null;\n        context.set(\"stage\", stage);\n        context.set(\"timer\", timer);\n    }\n};\n\n// Start sequence\nsendNextOutput();\n\nreturn null; // Initial input triggers sequence, no immediate output","outputs":4,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":520,"y":280,"wires":[[],[],[],[]],"inputLabels":["input"],"outputLabels":["stage1","stage2","stage3","reset"],"icon":"font-awesome/fa-wrench","info":"Triggers a sequence of outputs with configurable delays, ignoring inputs during active sequence.\r\n\r\n### Inputs\r\n: context (string) : Sets configuration (\"delay\" for delay time, \"reset\" to clear sequence).  \r\n: payload (any) : Input value to pass through outputs, ignored if sequence is running.\r\n\r\n### Outputs\r\n1. Stage 1\r\n: payload (any) : Input value, output immediately.\r\n2. Stage 2\r\n: payload (any) : Input value, output after delay.\r\n3. Stage 3\r\n: payload (any) : Input value, output after 2x delay.\r\n4. Reset\r\n: payload (any | boolean) : Input value, output after 3x delay; `false` on reset.\r\n\r\n### Details\r\nThe TimeSequence Block is a Sedona-inspired node for control systems, \r\ntriggering a sequence of four outputs (stage 1, stage 2, stage 3, reset) \r\nwith `msg.payload` passed through. Each output is delayed by a configurable \r\ninterval (default: 3000ms), set via `msg.context = \"delay\"` with `msg.payload` \r\nas a number or numeric string (e.g., `\"5000\"` for 5s). Reset the sequence via \r\n`msg.context = \"reset\"`, which outputs `false` to all ports and enables new sequences.\r\n\r\nThe input message is output sequentially on four ports, preserving properties \r\n(e.g., `msg.topic`). Inputs during an active sequence are ignored with warnings.  \r\nInvalid config values are rejected with warnings. Use in automation workflows for \r\ntimed control sequences, such as staged device activation.\r\n\r\n### Error Handling\r\n- Missing `msg.payload` for config: Shows \"missing payload\" (red), no output.  \r\n- Invalid delay (non-numeric, negative, e.g., `\"abc\"`, `-1`): Shows \"invalid delay\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n- Input during active sequence: Shows \"sequence running\" (red), no output.  \r\n\r\nStatus shows green for config (e.g., `delay: 5000 ms`, `state reset`), \r\nblue for output (e.g., `out: stage 1, in: \"start\"`), red/yellow for errors."},{"id":"dba522afa5d80237","type":"debug","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"debug 4","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3020,"y":760,"wires":[]},{"id":"2dfde4e5298188b8","type":"change","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"Contextual In3","rules":[{"t":"set","p":"context","pt":"msg","to":"in3","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":300,"y":1200,"wires":[["1872f6ae789c94e3","0520e98abca50ad5"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"dbe25112bf321e73","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"145","payloadType":"num","x":130,"y":1200,"wires":[[]]},{"id":"5b8d3cb044d997fe","type":"inject","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"Inject Flow","props":[{"p":"context","v":"command","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"stop","payloadType":"str","x":2400,"y":1140,"wires":[["d593f1e616d95e3a","1f5fbfa83de44f17"]]},{"id":"120dc0af132f1834","type":"function","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"Priority","func":"// Initialize state from context, with defaults\nlet priorities = context.get(\"priorities\") ?? {\n    priority1: null, priority2: null, priority3: null, priority4: null,\n    priority5: null, priority6: null, priority7: null, priority8: null,\n    priority9: null, priority10: null, priority11: null, priority12: null,\n    priority13: null, priority14: null, priority15: null, priority16: null\n};\nlet defaultValue = context.get(\"defaultValue\") ?? null;\nlet fallbackValue = context.get(\"fallbackValue\") ?? null;\n\n// Handle configuration updates via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    let value = msg.payload === null ? null : Number(msg.payload);\n    if (value !== null && isNaN(value)) {\n        node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a number or null)`);\n        node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n        return null;\n    }\n    if (msg.context === \"default\") {\n        defaultValue = value;\n        context.set(\"defaultValue\", defaultValue);\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: value === null ? \"default relinquished\" : `default set to ${value.toFixed(2)}`\n        });\n    } else if (msg.context === \"fallback\") {\n        fallbackValue = value;\n        context.set(\"fallbackValue\", fallbackValue);\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: value === null ? \"fallback relinquished\" : `fallback set to ${value.toFixed(2)}`\n        });\n    } else if (/^priority([1-9]|1[0-6])$/.test(msg.context)) {\n        priorities[msg.context] = value;\n        context.set(\"priorities\", priorities);\n        node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: value === null ? `${msg.context} relinquished` : `${msg.context} set to ${value.toFixed(2)}`\n        });\n    } else {\n        node.warn(`Unrecognized context property: ${msg.context}`);\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n        return null;\n    }\n    // Evaluate and output new priority value\n    return evaluatePriority();\n}\n\n// No action for non-config messages\nnode.warn(\"Invalid input: msg.context required\");\nnode.status({ fill: \"red\", shape: \"ring\", text: \"missing context\" });\nreturn null;\n\n// Evaluate highest priority value\nfunction evaluatePriority() {\n    let selectedValue = null;\n    let activePriority = null;\n\n    // Check priorities from 1 to 16\n    for (let i = 1; i <= 16; i++) {\n        const key = `priority${i}`;\n        if (priorities[key] !== null) {\n            selectedValue = priorities[key];\n            activePriority = key;\n            break;\n        }\n    }\n\n    // Fall back to default or fallback\n    if (selectedValue === null) {\n        if (defaultValue !== null) {\n            selectedValue = defaultValue;\n            activePriority = \"default\";\n        } else if (fallbackValue !== null) {\n            selectedValue = fallbackValue;\n            activePriority = \"fallback\";\n        }\n    }\n\n    let newMsg = {\n        payload: selectedValue,\n        diagnostics: { activePriority }\n    };\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: selectedValue === null ? \"out: null, no priority\" : `out: ${selectedValue.toFixed(2)}, ${activePriority}`\n    });\n\n    return newMsg;\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2780,"y":1440,"wires":[[]],"inputLabels":["input"],"outputLabels":["output"],"icon":"font-awesome/fa-wrench","info":"Implements a priority array with 16 levels, default, and fallback.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"priority1\" to \"priority16\", \"default\", \"fallback\").  \r\n: payload (number | null) : Value for priority/default/fallback, or null to relinquish.\r\n\r\n### Outputs\r\n: 1 (number | null) : Highest non-null priority value, with diagnostics.\r\n\r\n### Details\r\nManages a priority array with 16 slots (`priority1` to `priority16`), `default`, and `fallback`. \r\nOutputs the highest non-null value, prioritizing `priority1` (highest) to `priority16` (lowest), then `default` (normal flow logic), \r\nthen `fallback` (when default is null). Configure via `msg.context` with numeric values or `null` to relinquish. \r\nOutputs on each set or relinquish, including diagnostics (`activePriority`). Invalid inputs are rejected. Use in automation for \r\nprioritized control signals, e.g., user overrides.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid priority/default/fallback (non-numeric, not null): Shows \"invalid priority1\" (red), no output.  \r\n- Missing `msg.context`: Shows \"missing context\" (red), no output.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `priority1 set to 75.00`, `default relinquished`), blue for output (e.g., `out: 75.00, priority1`), \r\nred for errors, yellow for unknown context."},{"id":"888d83c237abd444","type":"inject","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"72","payloadType":"num","x":2390,"y":1480,"wires":[["a888cdaba015827d"]]},{"id":"df38c5b580499864","type":"inject","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"14","payloadType":"num","x":2390,"y":1520,"wires":[["21a92097619da35f"]]},{"id":"3648d6b8fc71f825","type":"inject","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"2","payloadType":"num","x":2390,"y":1440,"wires":[["1cf9b5547b3ae10b"]]},{"id":"116c5cd679953fd8","type":"inject","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"145","payloadType":"num","x":2390,"y":1560,"wires":[["112db50e2ccfd6c9"]]},{"id":"8c2543823b9cc919","type":"inject","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"Inject","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"num","x":2390,"y":1600,"wires":[["318026f4d66ff01c","3aea1f7badde5a56"]]},{"id":"318026f4d66ff01c","type":"function","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"Clear Priority","func":"msg.payload = null;\n\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2550,"y":1600,"wires":[[]]},{"id":"112db50e2ccfd6c9","type":"change","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"Contextual Priority1","rules":[{"t":"set","p":"context","pt":"msg","to":"priority1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":2570,"y":1560,"wires":[["120dc0af132f1834","b42ce734819d724b"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"21a92097619da35f","type":"change","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"Contextual Priority5","rules":[{"t":"set","p":"context","pt":"msg","to":"priority5","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":2570,"y":1520,"wires":[["120dc0af132f1834","b42ce734819d724b"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"a888cdaba015827d","type":"change","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"Contextual Priority8","rules":[{"t":"set","p":"context","pt":"msg","to":"priority8","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":2570,"y":1480,"wires":[["120dc0af132f1834","b42ce734819d724b"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"8a028827775b1b0f","type":"function","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"Call Status","func":"// Initialize state from context, with defaults\nlet call = context.get(\"call\") ?? false;\nlet status = context.get(\"status\") ?? false;\nlet alarm = context.get(\"alarm\") ?? false;\nlet alarmMessage = context.get(\"alarmMessage\") ?? \"\";\nlet statusTimeout = context.get(\"statusTimeout\") ?? 30; // Seconds\nlet clearDelay = context.get(\"clearDelay\") ?? 10; // Seconds\nlet normalOff = context.get(\"normalOff\") ?? false;\nlet normalOn = context.get(\"normalOn\") ?? true;\nlet runLostStatus = context.get(\"runLostStatus\") ?? false;\nlet noStatusOnRun = context.get(\"noStatusOnRun\") ?? true;\nlet runLostStatusMessage = context.get(\"runLostStatusMessage\") ?? \"Status lost during run\";\nlet noStatusOnRunMessage = context.get(\"noStatusOnRunMessage\") ?? \"No status received during run\";\nlet statusTimer = context.get(\"statusTimer\") ?? null;\nlet clearTimer = context.get(\"clearTimer\") ?? null;\nlet cleanupRegistered = context.get(\"cleanupRegistered\") ?? false;\n\n// Handle configuration updates and status inputs via msg.context\nif (msg.context) {\n    if (!msg.hasOwnProperty(\"payload\")) {\n        node.warn(\"Configuration update ignored: msg.payload missing\");\n        node.status({ fill: \"red\", shape: \"ring\", text: \"missing payload\" });\n        return null;\n    }\n    switch (msg.context) {\n        case \"statusTimeout\":\n        case \"clearDelay\":\n            let value = Number(msg.payload);\n            if (isNaN(value) || value <= 0) {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a positive number)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if (msg.context === \"statusTimeout\") {\n                statusTimeout = value;\n                context.set(\"statusTimeout\", statusTimeout);\n            } else {\n                clearDelay = value;\n                context.set(\"clearDelay\", clearDelay);\n            }\n            node.status({\n                fill: \"green\",\n                shape: \"dot\",\n                text: `${msg.context} set to ${value.toFixed(2)}`\n            });\n            return null;\n        case \"normalOff\":\n        case \"normalOn\":\n        case \"runLostStatus\":\n        case \"noStatusOnRun\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if (msg.context === \"normalOff\") {\n                normalOff = msg.payload;\n                context.set(\"normalOff\", normalOff);\n            } else if (msg.context === \"normalOn\") {\n                normalOn = msg.payload;\n                context.set(\"normalOn\", normalOn);\n            } else if (msg.context === \"runLostStatus\") {\n                runLostStatus = msg.payload;\n                context.set(\"runLostStatus\", runLostStatus);\n            } else {\n                noStatusOnRun = msg.payload;\n                context.set(\"noStatusOnRun\", noStatusOnRun);\n            }\n            node.status({\n                fill: \"green\",\n                shape: \"dot\",\n                text: `${msg.context} set to ${msg.payload}`\n            });\n            return checkStatusConditions();\n        case \"runLostStatusMessage\":\n        case \"noStatusOnRunMessage\":\n            if (typeof msg.payload !== \"string\") {\n                node.warn(`Invalid ${msg.context} value: ${msg.payload} (must be a string)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: `invalid ${msg.context}` });\n                return null;\n            }\n            if (msg.context === \"runLostStatusMessage\") {\n                runLostStatusMessage = msg.payload;\n                context.set(\"runLostStatusMessage\", runLostStatusMessage);\n            } else {\n                noStatusOnRunMessage = msg.payload;\n                context.set(\"noStatusOnRunMessage\", noStatusOnRunMessage);\n            }\n            node.status({\n                fill: \"green\",\n                shape: \"dot\",\n                text: `${msg.context} set`\n            });\n            return null;\n        case \"status\":\n            if (typeof msg.payload !== \"boolean\") {\n                node.warn(`Invalid status value: ${msg.payload} (must be a boolean)`);\n                node.status({ fill: \"red\", shape: \"ring\", text: \"invalid status\" });\n                return null;\n            }\n            if (!call) {\n                node.warn(\"Status ignored: no active call\");\n                node.status({ fill: \"red\", shape: \"ring\", text: \"status ignored\" });\n                return null;\n            }\n            status = msg.payload;\n            context.set(\"status\", status);\n            if (status && statusTimer) {\n                clearTimeout(statusTimer);\n                statusTimer = null;\n                context.set(\"statusTimer\", null);\n                alarm = false;\n                alarmMessage = \"\";\n                context.set(\"alarm\", alarm);\n                context.set(\"alarmMessage\", alarmMessage);\n            }\n            return checkStatusConditions();\n        default:\n            node.warn(`Unrecognized context property: ${msg.context}`);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"unknown context\" });\n            return null;\n    }\n}\n\n// Handle call input\nif (typeof msg.payload !== \"boolean\") {\n    node.warn(`Invalid call value: ${msg.payload} (must be a boolean)`);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"invalid call\" });\n    return null;\n}\n\n// Process call change\nif (msg.payload !== call) {\n    call = msg.payload;\n    context.set(\"call\", call);\n\n    // Clear existing timers\n    if (statusTimer) {\n        clearTimeout(statusTimer);\n        statusTimer = null;\n        context.set(\"statusTimer\", null);\n    }\n    if (clearTimer) {\n        clearTimeout(clearTimer);\n        clearTimer = null;\n        context.set(\"clearTimer\", null);\n    }\n\n    if (call) {\n        // Start call: reset status and alarm, set timeout\n        status = false;\n        alarm = false;\n        alarmMessage = \"\";\n        context.set(\"status\", status);\n        context.set(\"alarm\", alarm);\n        context.set(\"alarmMessage\", alarmMessage);\n        if (noStatusOnRun) {\n            statusTimer = setTimeout(() => {\n                if (!status) {\n                    alarm = true;\n                    alarmMessage = noStatusOnRunMessage;\n                    context.set(\"alarm\", alarm);\n                    context.set(\"alarmMessage\", alarmMessage);\n                    node.warn(alarmMessage);\n                    node.status({ fill: \"red\", shape: \"dot\", text: `no status on run, alarm: true` });\n                    node.send(sendOutputs());\n                }\n                statusTimer = null;\n                context.set(\"statusTimer\", null);\n            }, statusTimeout * 1000);\n            context.set(\"statusTimer\", statusTimer);\n        }\n    } else {\n        // Stop call: schedule status and alarm clear\n        clearTimer = setTimeout(() => {\n            status = false;\n            alarm = false;\n            alarmMessage = \"\";\n            context.set(\"status\", status);\n            context.set(\"alarm\", alarm);\n            context.set(\"alarmMessage\", alarmMessage);\n            clearTimer = null;\n            context.set(\"clearTimer\", null);\n            node.send(sendOutputs());\n            updateStatus();\n        }, clearDelay * 1000);\n        context.set(\"clearTimer\", clearTimer);\n    }\n}\n\n// Check status conditions\nfunction checkStatusConditions() {\n    if (call && runLostStatus) {\n        if (status !== normalOn) {\n            alarm = true;\n            alarmMessage = runLostStatusMessage;\n            context.set(\"alarm\", alarm);\n            context.set(\"alarmMessage\", alarmMessage);\n            node.status({ fill: \"red\", shape: \"dot\", text: `run lost, alarm: true` });\n            return sendOutputs();\n        }\n    }\n    if (!call && status !== normalOff) {\n        alarm = true;\n        alarmMessage = \"Status mismatch when off\";\n        context.set(\"alarm\", alarm);\n        context.set(\"alarmMessage\", alarmMessage);\n        node.status({ fill: \"red\", shape: \"dot\", text: `off mismatch, alarm: true` });\n        return sendOutputs();\n    }\n    if (!alarm || (status === normalOn && call) || (status === normalOff && !call)) {\n        alarm = false;\n        alarmMessage = \"\";\n        context.set(\"alarm\", alarm);\n        context.set(\"alarmMessage\", alarmMessage);\n    }\n    updateStatus();\n    return sendOutputs();\n}\n\n// Send outputs\nfunction sendOutputs() {\n    return [\n        { payload: call },\n        {\n            payload: {\n                call,\n                status,\n                alarm,\n                alarmMessage,\n                timeout: !!statusTimer\n            }\n        }\n    ];\n}\n\n// Update status\nfunction updateStatus() {\n    node.status({\n        fill: alarm ? \"red\" : \"blue\",\n        shape: \"dot\",\n        text: `call: ${call}, status: ${status}, alarm: ${alarm}`\n    });\n}\n\nupdateStatus();\nlet outputs = sendOutputs();\n\n// Cleanup on node close\nif (!cleanupRegistered) {\n    node.on(\"close\", () => {\n        if (statusTimer) clearTimeout(statusTimer);\n        if (clearTimer) clearTimeout(clearTimer);\n        context.set(\"statusTimer\", null);\n        context.set(\"clearTimer\", null);\n    });\n    cleanupRegistered = true;\n    context.set(\"cleanupRegistered\", true);\n}\n\nreturn outputs;","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2430,"y":1840,"wires":[[],[]],"inputLabels":["input"],"outputLabels":["call","diagnostics output"],"icon":"font-awesome/fa-wrench","info":"Issues calls to equipment (e.g., compressors, fans) with configurable status and alarm diagnostics.\r\n\r\n### Inputs\r\n: context (string) : Identifies config (\"statusTimeout\", \"clearDelay\", \"status\", \"normalOff\", \"normalOn\", \"runLostStatus\", \"noStatusOnRun\", \"runLostStatusMessage\", \"noStatusOnRunMessage\").  \r\n: payload (boolean | number | string) : Boolean for call/status/normalOff/normalOn/runLostStatus/noStatusOnRun, number for statusTimeout/clearDelay, string for messages.\r\n\r\n### Outputs\r\n: 1 (boolean) : Current call state.  \r\n: 2 (object) : Diagnostics with call, status, alarm, alarmMessage, timeout.\r\n\r\n### Details\r\nIssues a call (`true`) to equipment and expects a status response matching `normalOn` within `statusTimeout` (seconds). \r\nClears status and alarm after `clearDelay` (seconds) when call is removed (`false`), checking against `normalOff`. \r\nSets alarm (`true`) and custom messages for `runLostStatus` (status mismatch during run) or `noStatusOnRun` (no status response). \r\nConfigure via `msg.context` for timeouts, status, properties, or messages. Outputs call state and diagnostics \r\n(object with `call`, `status`, `alarm`, `alarmMessage`, `timeout`). Invalid inputs or alarms trigger warnings.\r\n\r\n### Error Handling\r\n- Missing `msg.payload`: Shows \"missing payload\" (red), no output.  \r\n- Invalid call/status/normalOff/normalOn/runLostStatus/noStatusOnRun (non-boolean): Shows \"invalid call\" (red), no output.  \r\n- Invalid statusTimeout/clearDelay (non-numeric, non-positive): Shows \"invalid statusTimeout\" (red), no output.  \r\n- Invalid messages (non-string): Shows \"invalid runLostStatusMessage\" (red), no output.  \r\n- Status without active call: Shows \"status ignored\" (red), no output.  \r\n- Alarm conditions: Shows \"run lost, alarm: true\" or \"no status on run, alarm: true\" (red), outputs diagnostics.  \r\n- Unknown `msg.context`: Shows \"unknown context\" (yellow), no output.  \r\n\r\nStatus: green for config (e.g., `normalOff set to true`), blue for output (e.g., `call: true, status: true, alarm: false`), \r\nred for alarms or errors, yellow for unknown context."},{"id":"a9a73830ef654c90","type":"change","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"Contextual In1","rules":[{"t":"set","p":"context","pt":"msg","to":"slots","tot":"str"},{"t":"set","p":"payload","pt":"msg","to":"4","tot":"num"}],"action":"","property":"","from":"","to":"","reg":false,"x":1540,"y":160,"wires":[["e85d8f0467e08e16"]],"info":"Change the context property to the expected input slot\r\nto work with contextual function nodes."},{"id":"0c712c5e203fe346","type":"inject","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":1350,"y":160,"wires":[["a9a73830ef654c90"]]},{"id":"e85d8f0467e08e16","type":"and-block","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"and","slots":"4","x":1760,"y":240,"wires":[["0cd7bb4b8e306245"]]},{"id":"4048fdc688a79374","type":"negate-block","z":"1d6822e3b60ba374","g":"08570307a3388294","name":"negate","x":1770,"y":420,"wires":[[]]},{"id":"12340aea52d767cb","type":"inject","z":"1d6822e3b60ba374","g":"f19a608dd6e58fd2","name":"Default","props":[{"p":"context","v":"setpoint","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"50","payloadType":"num","x":1570,"y":1160,"wires":[["6ae6562bf83d8b7f","27cf3190d7fc2d97","134508812af2d793"]]},{"id":"25fa803e81f75335","type":"compare-block","z":"1d6822e3b60ba374","g":"5f70baf7384cf6e3","name":"compare","setpoint":"59","x":1740,"y":600,"wires":[[],[],[]]},{"id":"134508812af2d793","type":"min-block","z":"1d6822e3b60ba374","g":"5360543001f5b360","name":"","min":50,"x":1750,"y":1460,"wires":[[]]},{"id":"4fc22d124d27b12c","type":"interpolate-block","z":"1d6822e3b60ba374","g":"f2f049190ff39eb1","name":"interpolate","points":"[{\"x\":0,\"y\":0},{\"x\":100,\"y\":100}]","x":1770,"y":1580,"wires":[[]]},{"id":"60b33f32a00511a0","type":"frequency-block","z":"1d6822e3b60ba374","g":"229300b1beb9bf03","name":"frequency","x":1760,"y":1760,"wires":[[]]},{"id":"cfc301742950d6ee","type":"pid-block","z":"1d6822e3b60ba374","g":"9df534ffc2085145","name":"pid","kp":0,"ki":0,"kd":0,"setpoint":0,"deadband":0,"dbBehavior":"ReturnToZero","outMin":"","outMax":"","maxChange":0,"directAction":false,"run":true,"x":1850,"y":940,"wires":[[]]},{"id":"3ed228585d61bff4","type":"count-block","z":"1d6822e3b60ba374","g":"02978c70d9a48d66","name":"count","x":2730,"y":80,"wires":[[]]},{"id":"01fd6587c9f33892","type":"add-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"add","slots":2,"x":3010,"y":400,"wires":[[]]},{"id":"df161a565dfda2c7","type":"subtract-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"subtract","slots":2,"x":3020,"y":500,"wires":[[]]},{"id":"f53652ab08a99953","type":"multiply-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"multiply","slots":2,"x":3020,"y":600,"wires":[[]]},{"id":"927b0539b644e3e7","type":"divide-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"divide","slots":2,"x":3020,"y":700,"wires":[[]]},{"id":"1f23ada6b13f037b","type":"sine-wave-block","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"sine-wave","lowerLimit":0,"upperLimit":100,"period":"10","periodUnits":"seconds","x":3020,"y":920,"wires":[["51b333a737aa829f","da208ed24d52cb6f"]]},{"id":"e78c5e13c2b2acbd","type":"triangle-wave-block","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"triangle-wave","lowerLimit":0,"upperLimit":100,"period":10,"periodUnits":"seconds","x":3030,"y":980,"wires":[[]]},{"id":"6a62f8e0fe1fad2a","type":"saw-tooth-wave-block","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"saw-tooth-wave","lowerLimit":0,"upperLimit":100,"period":10,"periodUnits":"seconds","x":3040,"y":1040,"wires":[[]]},{"id":"1f5fbfa83de44f17","type":"tick-tock-block","z":"1d6822e3b60ba374","g":"17021ab187712cc3","name":"tick-tock","period":10,"x":2780,"y":1160,"wires":[[]]},{"id":"b42ce734819d724b","type":"priority-block","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"priority","x":2790,"y":1500,"wires":[[]]},{"id":"cbd77dbeb3caa24f","type":"minmax-block","z":"1d6822e3b60ba374","g":"b5acac16791836bb","name":"minmax","min":0,"max":100,"x":2780,"y":1340,"wires":[[]]},{"id":"d6417864dc594bc1","type":"call-status-block","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"call-status","statusTimeout":30,"clearDelay":10,"runLostStatus":false,"noStatusOnRun":true,"runLostStatusMessage":"Status lost during run","noStatusOnRunMessage":"No status received during run","x":2420,"y":1800,"wires":[[]]},{"id":"701fd7be3a582274","type":"cache-block","z":"1d6822e3b60ba374","g":"9919aad00a5a6828","name":"cache","operationMode":"clone","x":910,"y":820,"wires":[[]]},{"id":"fbe110868dbb4ad8","type":"time-sequence-block","z":"1d6822e3b60ba374","g":"b6ff1d1d70ea795e","name":"time-sequence","delay":5000,"x":520,"y":200,"wires":[["c969c1bce8bc327b"],["bb50a79ad1278a40"],["35cb85789fdae36b"],["47d5f326953d211d"]]},{"id":"0520e98abca50ad5","type":"analog-switch-block","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"analog switch","slots":2,"x":540,"y":1080,"wires":[[]]},{"id":"4585b59e227a62f7","type":"scale-range-block","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"scale range","inMin":0,"inMax":100,"outMin":0,"outMax":80,"clamp":true,"x":530,"y":1320,"wires":[[]]},{"id":"6dd8aaf5258dce71","type":"load-sequence-block","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"load-sequence","enable":true,"hysteresis":0.5,"threshold1":10,"threshold2":20,"threshold3":30,"threshold4":40,"feedback1":false,"feedback2":false,"feedback3":false,"feedback4":false,"x":620,"y":1700,"wires":[["88a6bf234551bdb8"],["434f10270db2ac1e"],["106b4dbbf5f7e8f2"],["f198ab0461517005"]]},{"id":"1cf9b5547b3ae10b","type":"contextual-label-block","z":"1d6822e3b60ba374","g":"d813951177ea64b4","contextPropertyName":"default","x":2570,"y":1440,"wires":[["120dc0af132f1834","b42ce734819d724b"]]},{"id":"e3fab73e381919f3","type":"debug","z":"1d6822e3b60ba374","g":"463764c52c5452a5","name":"debug 1","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3640,"y":920,"wires":[]},{"id":"da208ed24d52cb6f","type":"tstat-block","z":"1d6822e3b60ba374","g":"463764c52c5452a5","name":"tstat","algorithm":"single","setpoint":70,"setpointType":"num","heatingSetpoint":"68","heatingSetpointType":"num","coolingSetpoint":"74","coolingSetpointType":"num","coolingOn":"74","coolingOnType":"num","coolingOff":"72","coolingOffType":"num","heatingOff":"68","heatingOffType":"num","heatingOn":"66","heatingOnType":"num","diff":2,"diffType":"num","anticipator":"0.5","anticipatorType":"num","ignoreAnticipatorCycles":"1","ignoreAnticipatorCyclesType":"num","isHeating":true,"x":3350,"y":1020,"wires":[["e3fab73e381919f3"],["2f4f2c1e3aabe1e3"],["cd727ef12158e609"]]},{"id":"507929b42eb201a6","type":"debug","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"debug 3","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":2980,"y":1880,"wires":[]},{"id":"c2ea92f0354786d1","type":"inject","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":2370,"y":2000,"wires":[["d0c26d8f043578bc"]]},{"id":"5b318b04ef936f99","type":"inject","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"false","payloadType":"bool","x":2370,"y":2060,"wires":[["c8a2476a10151b51"]]},{"id":"3724cc8f4302c7b4","type":"inject","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"Reset","props":[{"p":"context","v":"reset","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":2410,"y":1880,"wires":[["3e8c0628150d4577"]]},{"id":"3e8c0628150d4577","type":"oneshot-block","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"oneshot","duration":1000,"x":2620,"y":1880,"wires":[["507929b42eb201a6"]]},{"id":"d0c26d8f043578bc","type":"contextual-label-block","z":"1d6822e3b60ba374","g":"f7b552973c41a951","contextPropertyName":"inTrue","x":2570,"y":2000,"wires":[["40e072d63d30ce24"]]},{"id":"c8a2476a10151b51","type":"contextual-label-block","z":"1d6822e3b60ba374","g":"f7b552973c41a951","contextPropertyName":"inFalse","x":2570,"y":2060,"wires":[["40e072d63d30ce24"]]},{"id":"f2cdc9371de5dad5","type":"inject","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"Switch","props":[{"p":"context","v":"switch","vt":"str"},{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"true","payloadType":"bool","x":2610,"y":1960,"wires":[["40e072d63d30ce24"]]},{"id":"1e7ba71ca9266a50","type":"debug","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"debug 5","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3080,"y":2000,"wires":[]},{"id":"40e072d63d30ce24","type":"boolean-switch-block","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"","x":2820,"y":2060,"wires":[["1e7ba71ca9266a50"],["1e7ba71ca9266a50"],["7b5532729247a802"]]},{"id":"4b460e51fa20f61c","type":"delay-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","delayOn":"5","delayOnUnits":"seconds","delayOff":1000,"delayOffUnits":"milliseconds","x":2810,"y":760,"wires":[["dba522afa5d80237"]]},{"id":"27cf3190d7fc2d97","type":"max-block","z":"1d6822e3b60ba374","g":"f19a608dd6e58fd2","name":"","max":"54","x":1750,"y":1160,"wires":[[]]},{"id":"c5230994b10ae692","type":"modulo-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","slots":2,"x":3170,"y":660,"wires":[[]]},{"id":"3aea1f7badde5a56","type":"nullify-block","z":"1d6822e3b60ba374","g":"d813951177ea64b4","name":"","rules":[{"property":"payload","propertyType":"msg"}],"x":2530,"y":1640,"wires":[["112db50e2ccfd6c9"]]},{"id":"a2ae079529ab6a2e","type":"accumulate-block","z":"1d6822e3b60ba374","g":"02978c70d9a48d66","name":"","mode":"true","x":2720,"y":240,"wires":[[]]},{"id":"afc31c9c894ed311","type":"edge-block","z":"1d6822e3b60ba374","name":"","algorithm":"false-to-true","x":2970,"y":100,"wires":[["cf5a806b2e25e5de"]]},{"id":"cf5a806b2e25e5de","type":"accumulate-block","z":"1d6822e3b60ba374","name":"","mode":"true","x":3140,"y":100,"wires":[[]]},{"id":"7b5532729247a802","type":"debug","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"debug 2","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":3060,"y":2060,"wires":[]},{"id":"99c1ee797a7b9041","type":"debug","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"debug 6","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":920,"y":980,"wires":[]},{"id":"1aa1f0bfecc5bee9","type":"debug","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"debug 7","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":920,"y":1020,"wires":[]},{"id":"25134203b1cab712","type":"debug","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"debug 8","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":920,"y":1060,"wires":[]},{"id":"0cd7bb4b8e306245","type":"debug","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"debug 10","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":1920,"y":240,"wires":[]},{"id":"810cdb5fe25c7c7e","type":"or-block","z":"1d6822e3b60ba374","g":"ec9549b63c4af34f","name":"","slots":"4","x":1750,"y":320,"wires":[[]]},{"id":"9d9320bf3cf1ea53","type":"comment-block","z":"1d6822e3b60ba374","g":"f7b552973c41a951","name":"comment","comment":"No comment","statusDisplay":"default","x":2620,"y":1800,"wires":[[]]},{"id":"72e363ad9893b593","type":"average-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","sampleSize":10,"minValid":1,"minValidType":"num","maxValid":150,"maxValidType":"num","x":3010,"y":340,"wires":[[]]},{"id":"5eb0fb0078391fe1","type":"convert-block","z":"1d6822e3b60ba374","g":"59013327c751cd0f","name":"","conversion":"C to F","x":3180,"y":440,"wires":[[]]},{"id":"a680dfe9c7cf25bc","type":"inject","z":"1d6822e3b60ba374","name":"Inject Flow","props":[{"p":"payload"}],"repeat":"5","crontab":"","once":true,"onceDelay":"0.2","topic":"","payload":"65","payloadType":"num","x":1370,"y":2040,"wires":[["b8b8f6940c3ab362"]]},{"id":"0bd8ee770692e335","type":"inject","z":"1d6822e3b60ba374","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"-1000","payloadType":"num","x":3080,"y":1320,"wires":[["16b5098ad41de8dc"]]},{"id":"16b5098ad41de8dc","type":"change","z":"1d6822e3b60ba374","name":"","rules":[{"t":"set","p":"testpoint","pt":"global","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":3330,"y":1320,"wires":[[]]},{"id":"e8dc25f1a724a2e1","type":"thermistor-block","z":"1d6822e3b60ba374","name":"","R_fixed":23500,"Vsupply":5.08,"Vref":4.096,"ADC_max":32768,"x":2080,"y":1540,"wires":[[],[]]},{"id":"be95a707eba61951","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"1","payloadType":"num","x":130,"y":1040,"wires":[["727da4e3e54228da"]]},{"id":"6eb5af6978226b9a","type":"inject","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"2","payloadType":"num","x":130,"y":1080,"wires":[["727da4e3e54228da"]]},{"id":"0999e4ec2194ecab","type":"hysteresis-block","z":"1d6822e3b60ba374","g":"18db10675ce5c323","name":"","upperLimit":50,"upperLimitType":"num","lowerLimit":30,"lowerLimitType":"num","upperLimitThreshold":2,"upperLimitThresholdType":"num","lowerLimitThreshold":2,"lowerLimitThresholdType":"num","x":740,"y":1020,"wires":[["99c1ee797a7b9041"],["1aa1f0bfecc5bee9"],["25134203b1cab712"]]},{"id":"b8b8f6940c3ab362","type":"changeover-block","z":"1d6822e3b60ba374","name":"","algorithm":"single","setpoint":"70","setpointType":"num","deadband":"2","heatingSetpoint":"68","heatingSetpointType":"num","coolingSetpoint":"74","coolingSetpointType":"num","extent":"1","swapTime":"300","swapTimeType":"num","minTempSetpoint":"55","minTempSetpointType":"num","maxTempSetpoint":"90","maxTempSetpointType":"num","initWindow":"10","operationMode":"auto","x":1550,"y":2040,"wires":[[]]},{"id":"f39cc230dd2a699e","type":"history-collector","z":"1d6822e3b60ba374","g":"be0e12cf52a203c2","historyConfig":"2e892b1fa8276829","seriesName":"OutsideTemp","tags":"tag1=physical,tag2=input","storageType":"batchObject","name":"","x":3290,"y":1480,"wires":[["5b83de0d0bdb16a5"]]},{"id":"f19276a4be8aee8f","type":"link out","z":"1d6822e3b60ba374","g":"be0e12cf52a203c2","name":"Out To History Processor","mode":"link","links":["4fcb69110dc93052"],"x":3635,"y":1480,"wires":[]},{"id":"45e2c09ca75f8289","type":"join","z":"1d6822e3b60ba374","g":"c9ce10db918f0a6f","name":"Batch Payloads","mode":"custom","build":"array","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","useparts":false,"accumulate":false,"timeout":"10","count":"100","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"num","reduceFixup":"","x":3920,"y":1480,"wires":[["4b5896ae5ffa8151","519872a6db742acf"]]},{"id":"968e30ac24b16b23","type":"comment","z":"1d6822e3b60ba374","g":"c9ce10db918f0a6f","name":"Write to InfluxDBv2","info":"","x":3910,"y":1440,"wires":[]},{"id":"4b5896ae5ffa8151","type":"influxdb batch","z":"1d6822e3b60ba374","d":true,"g":"c9ce10db918f0a6f","influxdb":"ce2f3c2cc488f01e","precision":"","retentionPolicy":"","name":"Batch [v2.0] Default","database":"database","precisionV18FluxV20":"ns","retentionPolicyV18Flux":"","org":"BldgBlocks","bucket":"sensor_data","x":4190,"y":1480,"wires":[]},{"id":"519872a6db742acf","type":"debug","z":"1d6822e3b60ba374","g":"c9ce10db918f0a6f","name":"debug 11","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":4160,"y":1440,"wires":[]},{"id":"4fcb69110dc93052","type":"link in","z":"1d6822e3b60ba374","g":"c9ce10db918f0a6f","name":"History/Collector","links":["f19276a4be8aee8f"],"x":3755,"y":1480,"wires":[["45e2c09ca75f8289"]]},{"id":"5b83de0d0bdb16a5","type":"global-setter","z":"1d6822e3b60ba374","g":"be0e12cf52a203c2","name":"","path":"outsideTemp","property":"payload","defaultValue":"70","defaultValueType":"num","writePriority":"default","writePriorityType":"dropdown","x":3490,"y":1480,"wires":[["f19276a4be8aee8f"]]},{"id":"e13981b2f0ddd358","type":"websocket in","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"","server":"542f751e15337c46","client":"","x":3460,"y":1840,"wires":[["a59c711e960f436a"]]},{"id":"baa3602f64e53454","type":"websocket out","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"","server":"542f751e15337c46","client":"","x":4560,"y":1840,"wires":[]},{"id":"29a28768408478bc","type":"network-read","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"","registry":"5b1d9bc3fbb7f85f","x":4000,"y":1840,"wires":[["baa3602f64e53454"]]},{"id":"dbbadd3e06f9f155","type":"inject","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"Simulate OnChange","props":[{"p":"pointId","v":"2","vt":"num"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":3740,"y":1780,"wires":[["29a28768408478bc"]]},{"id":"e31ac485f06364d7","type":"network-write","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"","registry":"5b1d9bc3fbb7f85f","x":4000,"y":1900,"wires":[["baa3602f64e53454"]]},{"id":"a59c711e960f436a","type":"switch","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"Branch Commands","property":"action","propertyType":"msg","rules":[{"t":"eq","v":"read","vt":"str"},{"t":"eq","v":"write","vt":"str"},{"t":"eq","v":"discover","vt":"str"},{"t":"eq","v":"help","vt":"str"}],"checkall":"false","repair":false,"outputs":4,"x":3740,"y":1840,"wires":[["29a28768408478bc"],["e31ac485f06364d7"],["7d2dae95cd8ab3ce"],["9292e07ea8f4a75b"]]},{"id":"7d2dae95cd8ab3ce","type":"function","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"List all network ready global keys in listed contexts","func":"// Get all available context stores\nconst contextStores = ['default', 'persistent'];\nlet networkProperties = {};\n\nfor (let store of contextStores) {\n    try {\n        let keys = global.keys(store);\n        networkProperties[store] = {};\n\n        for (let k of keys) {\n            let storedObject = global.get(k, store);\n\n            // Check if the stored object has both required properties\n            if (storedObject &&\n                typeof storedObject === 'object' &&\n                storedObject.hasOwnProperty('metadata') &&\n                storedObject.hasOwnProperty('network')) {\n\n                networkProperties[store][k] = {\n                    store: storedObject.metadata.store,\n                    registry: storedObject.network.registry,\n                    path: storedObject.metadata.path,\n                    type: storedObject.metadata.type,\n                    pointId: storedObject.network.pointId,\n                    writable: storedObject.network.writable\n                };\n            }\n        }\n\n        // Remove empty store entries\n        if (Object.keys(networkProperties[store]).length === 0) {\n            delete networkProperties[store];\n        }\n    } catch (error) {\n        // Skip stores that might not be available or accessible\n        continue;\n    }\n}\n\nmsg = { networkProperties };\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":4120,"y":1960,"wires":[["baa3602f64e53454"]]},{"id":"9292e07ea8f4a75b","type":"function","z":"1d6822e3b60ba374","g":"70cd8faca5d123a0","name":"Return available commands","func":"const help = {\n    read: \"Request data from the server by pointId\\nExample: `{ action: \\\"read\\\", pointId: \\\"101\\\" }`\",\n    write: \"Write data to the server by pointId, make sure it is writable and of the correct type\\nExample: `{ action: \\\"write\\\", pointId: 101, priority: 16, value: 75.5 (null || \\\"null\\\" to release) }`\",\n    discover: \"Discover available points on the server\\nExample: `{ action: \\\"discover\\\" }`\",\n    help: \"Display this help message\\nExample: `{ action: \\\"help\\\" }`\"\n};\n\nmsg = help;\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":4050,"y":2020,"wires":[["baa3602f64e53454"]]},{"id":"332af5ef12bc5960","type":"global-setter","z":"1d6822e3b60ba374","g":"eb3afd2a7fb103f7","name":"","path":"furnace/outputs/heat","property":"payload","defaultValue":"false","defaultValueType":"bool","writePriority":"default","writePriorityType":"dropdown","x":3740,"y":2160,"wires":[["6e1f9bd8fbbfe06c"]]},{"id":"b78f816ea9e452b7","type":"inject","z":"1d6822e3b60ba374","g":"eb3afd2a7fb103f7","name":"","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"545","payloadType":"num","x":3400,"y":2160,"wires":[["488b183e9506554d"]]},{"id":"6e1f9bd8fbbfe06c","type":"network-register","z":"1d6822e3b60ba374","g":"eb3afd2a7fb103f7","name":"","registry":"5b1d9bc3fbb7f85f","pointId":"2","writable":true,"x":4090,"y":2160,"wires":[[]]},{"id":"488b183e9506554d","type":"units-block","z":"1d6822e3b60ba374","g":"eb3afd2a7fb103f7","name":"","unit":"°F","x":3505,"y":2160,"wires":[["332af5ef12bc5960"]],"l":false},{"id":"2e892b1fa8276829","type":"history-config","series":[{"seriesName":"OutsideTemp","seriesUnits":"°F"}],"name":"default","tags":[{"tagName":"tag0","tagValue":"virtual"},{"tagName":"tag1","tagValue":"physical"},{"tagName":"tag2","tagValue":"input"},{"tagName":"tag3","tagValue":"output"}]},{"id":"ce2f3c2cc488f01e","type":"influxdb","hostname":"127.0.0.1","port":8086,"protocol":"http","database":"database","name":"Default","usetls":false,"tls":"","influxdbVersion":"2.0","url":"http://localhost:8086","timeout":"20","rejectUnauthorized":true},{"id":"542f751e15337c46","type":"websocket-listener","path":"/endpoint/ws/serverDevice","wholemsg":"true"},{"id":"5b1d9bc3fbb7f85f","type":"network-point-registry","name":"Main"},{"id":"9bc1157a87f5cec3","type":"global-config","env":[],"modules":{"node-red-node-random":"0.4.1","@bldgblocks/node-red-contrib-control":"0.1.32","node-red-contrib-influxdb":"0.7.0"}}]