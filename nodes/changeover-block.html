<script type="text/html" data-template-name="changeover-block">
    <div class="form-row">
        <label for="node-input-name" title="Display name shown on the canvas"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <label for="node-input-algorithm" title="Control algorithm type"><i class="fa fa-cog"></i> Algorithm</label>
        <select id="node-input-algorithm">
            <option value="single">Single Setpoint</option>
            <option value="split">Split Setpoints</option>
        </select>
    </div>
    <div class="form-row single-only">
        <label for="node-input-setpoint" title="Target temperature setpoint (number from num, msg, flow, or global)"><i class="fa fa-thermometer-half"></i> Setpoint</label>
        <input type="text" id="node-input-setpoint" class="node-input-typed" placeholder="70">
        <input type="hidden" id="node-input-setpointType">
    </div>
    <div class="form-row single-only">
        <label for="node-input-deadband" title="Temperature range for no action (positive number)"><i class="fa fa-arrows-v"></i> Deadband</label>
        <input type="text" id="node-input-deadband" placeholder="2">
    </div>
    <div class="form-row split-only" style="display: none;">
        <label for="node-input-heatingSetpoint" title="Heating setpoint for split algorithm (number from num, msg, flow, or global)"><i class="fa fa-thermometer-empty"></i> Heating Setpoint</label>
        <input type="text" id="node-input-heatingSetpoint" class="node-input-typed" placeholder="68">
        <input type="hidden" id="node-input-heatingSetpointType">
    </div>
    <div class="form-row split-only" style="display: none;">
        <label for="node-input-coolingSetpoint" title="Cooling setpoint for split algorithm (number from num, msg, flow, or global)"><i class="fa fa-thermometer-full"></i> Cooling Setpoint</label>
        <input type="text" id="node-input-coolingSetpoint" class="node-input-typed" placeholder="74">
        <input type="hidden" id="node-input-coolingSetpointType">
    </div>
    <div class="form-row split-only" style="display: none;">
        <div id="split-setpoint-warning" style="color: red; display: none; margin-top: 5px;">
            Cooling setpoint must be greater than heating setpoint
        </div>
    </div>
    <div class="form-row">
        <label for="node-input-extent" title="Temperature offset for mode switching thresholds (non-negative number)"><i class="fa fa-tachometer"></i> Extent</label>
        <input type="text" id="node-input-extent" placeholder="1">
    </div>
    <div class="form-row">
        <label for="node-input-swapTime" title="Minimum time before mode change (seconds, minimum 60, from num, msg, flow, or global)"><i class="fa fa-clock-o"></i> Swap Time</label>
        <input type="text" id="node-input-swapTime" class="node-input-typed" placeholder="300">
        <input type="hidden" id="node-input-swapTimeType">
    </div>
    <div class="form-row">
        <label for="node-input-minTempSetpoint" title="Minimum allowable setpoint"><i class="fa fa-thermometer-empty"></i> Min Setpoint</label>
        <input type="text" id="node-input-minTempSetpoint" placeholder="55">
    </div>
    <div class="form-row">
        <label for="node-input-maxTempSetpoint" title="Maximum allowable setpoint"><i class="fa fa-thermometer-full"></i> Max Setpoint</label>
        <input type="text" id="node-input-maxTempSetpoint" placeholder="90">
    </div>
    <div class="form-row">
        <label for="node-input-initWindow" title="Initialization window to collect inputs before mode selection (seconds, non-negative number)"><i class="fa fa-hourglass-start"></i> Init Window</label>
        <input type="text" id="node-input-initWindow" placeholder="10">
    </div>
    <div class="form-row">
        <label for="node-input-operationMode" title="Operation mode"><i class="fa fa-cogs"></i> Operation Mode</label>
        <select id="node-input-operationMode">
            <option value="auto">Auto</option>
            <option value="heat">Heat</option>
            <option value="cool">Cool</option>
        </select>
    </div>
    <div class="form-row">
        <label><i class="fa fa-info-circle"></i> Effective Setpoints</label>
        <pre id="node-runtime-changes" style="color: #555; white-space: pre-wrap;">Effective Setpoints: Initializing</pre>
    </div>
</script>

<script type="text/javascript">
    RED.nodes.registerType("changeover-block", {
        category: "control",
        color: "#301934",
        defaults: {
            name: { value: "" },
            algorithm: { value: "single" },
            setpoint: { value: "70" },
            setpointType: { value: "num" },
            deadband: { value: "2" },
            heatingSetpoint: { value: "68" },
            heatingSetpointType: { value: "num" },
            coolingSetpoint: { value: "74" },
            coolingSetpointType: { value: "num" },
            extent: { value: "1" },
            swapTime: { value: "300" },
            swapTimeType: { value: "num" },
            minTempSetpoint: { value: "55" },
            maxTempSetpoint: { value: "90" },
            initWindow: { value: "10" },
            operationMode: { value: "auto" }
        },
        inputs: 1,
        outputs: 2,
        inputLabels: ["temperature"],
        outputLabels: ["isHeating", "status"],
        icon: "font-awesome/fa-retweet",
        paletteLabel: "changeover",
        label: function() {
            return this.name || "changeover";
        },
        oneditprepare: function() {
            const node = this;
            const $algorithm = $("#node-input-algorithm");
            const $singleFields = $(".single-only");
            const $splitFields = $(".split-only");

            try {
                // Initialize typed inputs
                $("#node-input-setpoint").typedInput({
                    default: "num",
                    types: ["num", "msg", "flow", "global"],
                    typeField: "#node-input-setpointType"
                }).typedInput("type", node.setpointType || "num").typedInput("value", node.setpoint || "70");

                $("#node-input-heatingSetpoint").typedInput({
                    default: "num",
                    types: ["num", "msg", "flow", "global"],
                    typeField: "#node-input-heatingSetpointType"
                }).typedInput("type", node.heatingSetpointType || "num").typedInput("value", node.heatingSetpoint || "68");

                $("#node-input-coolingSetpoint").typedInput({
                    default: "num",
                    types: ["num", "msg", "flow", "global"],
                    typeField: "#node-input-coolingSetpointType"
                }).typedInput("type", node.coolingSetpointType || "num").typedInput("value", node.coolingSetpoint || "74");

                $("#node-input-swapTime").typedInput({
                    default: "num",
                    types: ["num", "msg", "flow", "global"],
                    typeField: "#node-input-swapTimeType"
                }).typedInput("type", node.swapTimeType || "num").typedInput("value", node.swapTime || "300");

                // Toggle fields based on algorithm
                function toggleFields() {
                    if ($algorithm.val() === "single") {
                        $singleFields.show();
                        $splitFields.hide();
                        $("#split-setpoint-warning").hide();
                    } else {
                        $singleFields.hide();
                        $splitFields.show();
                        validateSplitSetpoints();
                    }
                }

                $algorithm.on("change", toggleFields);
                toggleFields();

                // Fetch runtime values or use configured values for effective setpoints
                $.getJSON(`/changeover-block-runtime/${node.id}`, function(data) {
                    const runtime = data || {};
                    const changes = [];

                    const algorithm = runtime.algorithm || node.algorithm;
                    const extent = runtime.extent !== undefined ? runtime.extent : Number(node.extent);

                    if (algorithm === "single") {
                        const setpoint = runtime.setpoint !== undefined ? parseFloat(runtime.setpoint) : Number(node.setpoint);
                        const deadband = runtime.deadband !== undefined ? runtime.deadband : Number(node.deadband);
                        const effectiveHeating = setpoint - deadband / 2 - extent;
                        const effectiveCooling = setpoint + deadband / 2 + extent;
                        changes.push(`effectiveHeatingThreshold: ${effectiveHeating.toFixed(1)}`);
                        changes.push(`effectiveCoolingThreshold: ${effectiveCooling.toFixed(1)}`);
                    } else {
                        const heatingSetpoint = runtime.heatingSetpoint !== undefined ? parseFloat(runtime.heatingSetpoint) : Number(node.heatingSetpoint);
                        const coolingSetpoint = runtime.coolingSetpoint !== undefined ? parseFloat(runtime.coolingSetpoint) : Number(node.coolingSetpoint);
                        const effectiveHeating = heatingSetpoint - extent;
                        const effectiveCooling = coolingSetpoint + extent;
                        changes.push(`effectiveHeatingThreshold: ${effectiveHeating.toFixed(1)}`);
                        changes.push(`effectiveCoolingThreshold: ${effectiveCooling.toFixed(1)}`);
                    }

                    const displayText = `Effective Setpoints:\n${changes.join("\n")}`;
                    $("#node-runtime-changes").text(displayText);
                }).fail(function() {
                    const changes = [];

                    const algorithm = node.algorithm;
                    const extent = Number(node.extent);

                    if (algorithm === "single") {
                        const setpoint = Number(node.setpoint);
                        const deadband = Number(node.deadband);
                        const effectiveHeating = setpoint - deadband / 2 - extent;
                        const effectiveCooling = setpoint + deadband / 2 + extent;
                        changes.push(`effectiveHeatingThreshold: ${effectiveHeating.toFixed(1)}`);
                        changes.push(`effectiveCoolingThreshold: ${effectiveCooling.toFixed(1)}`);
                    } else {
                        const heatingSetpoint = Number(node.heatingSetpoint);
                        const coolingSetpoint = Number(node.coolingSetpoint);
                        const effectiveHeating = heatingSetpoint - extent;
                        const effectiveCooling = coolingSetpoint + extent;
                        changes.push(`effectiveHeatingThreshold: ${effectiveHeating.toFixed(1)}`);
                        changes.push(`effectiveCoolingThreshold: ${effectiveCooling.toFixed(1)}`);
                    }

                    const displayText = `Effective Setpoints:\n${changes.join("\n")}`;
                    $("#node-runtime-changes").text(displayText);
                });

                // Validate non-typed inputs
                $("#node-input-deadband").on("input", function() {
                    const val = parseFloat($(this).val());
                    $(this).toggleClass("input-error", isNaN(val) || val <= 0);
                });

                $("#node-input-extent").on("input", function() {
                    const val = parseFloat($(this).val());
                    $(this).toggleClass("input-error", isNaN(val) || val < 0);
                });

                $("#node-input-swapTime").on("input", function() {
                    const val = parseFloat($(this).typedInput("value"));
                    $(this).toggleClass("input-error", isNaN(val) || val < 60);
                });

                $("#node-input-minTempSetpoint").on("input", function() {
                    const val = parseFloat($(this).val());
                    const max = parseFloat($("#node-input-maxTempSetpoint").val());
                    $(this).toggleClass("input-error", isNaN(val) || val >= max);
                });

                $("#node-input-maxTempSetpoint").on("input", function() {
                    const val = parseFloat($(this).val());
                    const min = parseFloat($("#node-input-minTempSetpoint").val());
                    $(this).toggleClass("input-error", isNaN(val) || val <= min);
                });

                $("#node-input-initWindow").on("input", function() {
                    const val = parseFloat($(this).val());
                    $(this).toggleClass("input-error", isNaN(val) || val < 0);
                });

                // Validate split setpoints
                function validateSplitSetpoints() {
                    if ($("#node-input-algorithm").val() !== "split") {
                        $("#split-setpoint-warning").hide();
                        $("#node-input-heatingSetpoint").removeClass("input-error");
                        $("#node-input-coolingSetpoint").removeClass("input-error");
                        return;
                    }
                    const heatingSetpoint = parseFloat($("#node-input-heatingSetpoint").typedInput("value"));
                    const coolingSetpoint = parseFloat($("#node-input-coolingSetpoint").typedInput("value"));
                    const isInvalid = isNaN(heatingSetpoint) || isNaN(coolingSetpoint) || coolingSetpoint <= heatingSetpoint;
                    $("#node-input-heatingSetpoint").toggleClass("input-error", isInvalid);
                    $("#node-input-coolingSetpoint").toggleClass("input-error", isInvalid);
                    $("#split-setpoint-warning").toggle(isInvalid);
                }

                $("#node-input-heatingSetpoint").typedInput("on", "change", validateSplitSetpoints);
                $("#node-input-coolingSetpoint").typedInput("on", "change", validateSplitSetpoints);
            } catch (err) {
                console.error("Error in changeover-block oneditprepare:", err);
            }
        },
        oneditsave: function() {
            $("#node-input-setpointType").val($("#node-input-setpoint").typedInput("type"));
            $("#node-input-setpoint").val($("#node-input-setpoint").typedInput("value"));
            $("#node-input-heatingSetpointType").val($("#node-input-heatingSetpoint").typedInput("type"));
            $("#node-input-heatingSetpoint").val($("#node-input-heatingSetpoint").typedInput("value"));
            $("#node-input-coolingSetpointType").val($("#node-input-coolingSetpoint").typedInput("type"));
            $("#node-input-coolingSetpoint").val($("#node-input-coolingSetpoint").typedInput("value"));
            $("#node-input-swapTimeType").val($("#node-input-swapTime").typedInput("type"));
            $("#node-input-swapTime").val($("#node-input-swapTime").typedInput("value"));
        },
        oneditvalidate: function() {
            const deadband = parseFloat($("#node-input-deadband").val());
            const extent = parseFloat($("#node-input-extent").val());
            const swapTime = parseFloat($("#node-input-swapTime").typedInput("value"));
            const minTemp = parseFloat($("#node-input-minTempSetpoint").val());
            const maxTemp = parseFloat($("#node-input-maxTempSetpoint").val());
            const initWindow = parseFloat($("#node-input-initWindow").val());

            if ($("#node-input-algorithm").val() === "single") {
                if (isNaN(deadband) || deadband <= 0) {
                    $("#node-input-deadband").addClass("input-error");
                    return false;
                }
            } else {
                const heatingSetpoint = parseFloat($("#node-input-heatingSetpoint").typedInput("value"));
                const coolingSetpoint = parseFloat($("#node-input-coolingSetpoint").typedInput("value"));
                if (isNaN(heatingSetpoint) || isNaN(coolingSetpoint) || coolingSetpoint <= heatingSetpoint) {
                    $("#node-input-heatingSetpoint").addClass("input-error");
                    $("#node-input-coolingSetpoint").addClass("input-error");
                    $("#split-setpoint-warning").show();
                    return false;
                }
            }

            if (isNaN(extent) || extent < 0) {
                $("#node-input-extent").addClass("input-error");
                return false;
            }
            if (isNaN(swapTime) || swapTime < 60) {
                $("#node-input-swapTime").addClass("input-error");
                return false;
            }
            if (isNaN(minTemp) || isNaN(maxTemp) || minTemp >= maxTemp) {
                $("#node-input-minTempSetpoint").addClass("input-error");
                $("#node-input-maxTempSetpoint").addClass("input-error");
                return false;
            }
            if (isNaN(initWindow) || initWindow < 0) {
                $("#node-input-initWindow").addClass("input-error");
                return false;
            }
            return true;
        }
    });
</script>

<script type="text/markdown" data-help-name="changeover-block">
Manages HVAC mode switching between heating and cooling based on temperature inputs and setpoint configurations.

### Inputs
: context (string) : Configures node settings (`"operationMode"`, `"algorithm"`, `"setpoint"`, `"deadband"`, `"heatingSetpoint"`, `"coolingSetpoint"`, `"extent"`, `"swapTime"`, `"minTempSetpoint"`, `"maxTempSetpoint"`, `"initWindow"`). Unknown values trigger a warning.
: payload (number | string) : Temperature for mode evaluation; configuration value with `msg.context`.

### Outputs
: isHeating (boolean) : `true` for heating, `false` for cooling, with `msg.context = "isHeating"`.
: status (object) : `{ mode, isHeating, heatingSetpoint, coolingSetpoint, temperature }`.

### Algorithms
The node supports two algorithms for determining HVAC mode:

- **Single Setpoint**:
  - Uses a single `setpoint`, `deadband`, and `extent`.
  - **Heating** is triggered if the input temperature is below `setpoint - deadband/2 - extent`.
  - **Cooling** is triggered if the temperature exceeds `setpoint + deadband/2 + extent`.
  - Example: With `setpoint=70`, `deadband=2`, `extent=1`, heating starts below `70 - 2/2 - 1 = 68`, and cooling starts above `70 + 2/2 + 1 = 72`.
  - The `extent` widens thresholds to prevent nuisance mode changes due to overshoot.

- **Split Setpoint**:
  - Uses separate `heatingSetpoint`, `coolingSetpoint`, and `extent`.
  - **Heating** is triggered if the temperature is below `heatingSetpoint - extent`.
  - **Cooling** is triggered if the temperature exceeds `coolingSetpoint + extent`.
  - Example: With `heatingSetpoint=68`, `coolingSetpoint=74`, `extent=1`, heating starts below `68 - 1 = 67`, and cooling starts above `74 + 1 = 75`.
  - Ensures `coolingSetpoint >= heatingSetpoint` to avoid overlap.

### Details
Controls HVAC mode (heating or cooling) based on `msg.payload` temperature compared to setpoints. The node caches the last temperature to make an immediate mode decision after the `initWindow` period, avoiding delays.

- In **auto** mode, the node switches modes based on the algorithm thresholds, requiring the condition to persist for `swapTime` seconds (minimum 60s). A countdown is shown (e.g., `pending: cooling in 120s`).
- In **heat** or **cool** mode, the node locks to heating or cooling, respectively, ignoring temperature inputs.
- The `extent` widens switching thresholds to prevent unnecessary mode changes.
- Configuration options can be set via the editor or `msg.context` (e.g., `{ context: "setpoint", payload: 72 }`).
- Effective setpoints (`effectiveHeatingThreshold`, `effectiveCoolingThreshold`) are always displayed in "Effective Setpoints" for both new and active nodes, showing the calculated mode-switching thresholds.
- State (`currentMode`, `lastTemperature`) persists across redeployments.

### Error Handling
- Missing `msg`: No output, status: `red ring, invalid message`.
- Missing `msg.payload` for temperature: No output, status: `red ring, missing temperature`.
- Missing `msg.payload` for context: No output, status: `red ring, missing payload for X`.
- Invalid temperature (non-numeric): No output, status: `red ring, invalid temperature`.
- Invalid `operationMode` (not `auto`, `heat`, `cool`): No output, status: `red ring, invalid operationMode`.
- Invalid `algorithm` (not `single`, `split`): No output, status: `red ring, invalid algorithm`.
- Invalid numeric context (e.g., non-numeric, out-of-range, `swapTime < 60`): No output, status: `red ring, invalid X`.
- Wrong context for algorithm (e.g., `setpoint` in split): No output, status: `red ring, X not used in Y algorithm`.
- Unknown `msg.context`: No output, status: `yellow ring, unknown context`.

### Status
- Green (dot): Configuration updated (e.g., `in: setpoint=70.0, out: heating`).
- Blue (dot): Mode changed (e.g., `in: temp=65.0, out: heating`).
- Blue (ring): No mode change (e.g., `in: temp=70.0, out: cooling, pending: heating in 120s`).
- Red (ring): Errors (e.g., `missing temperature`, `invalid setpoint`).
- Yellow (ring): Initializing (e.g., `initializing, out: heating`) or warning (e.g., `unknown context`).

### References
- [Node-RED Documentation](https://nodered.org/docs/)
- [GitHub Repository](https://github.com/BldgBlocks/node-red-contrib-buildingblocks-control.git)
</script>