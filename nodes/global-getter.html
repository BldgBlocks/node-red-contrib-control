<script type="text/html" data-template-name="global-getter">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <div class="form-row">
        <label for="node-input-targetNode"><i class="fa fa-crosshairs"></i> Source</label>
        <input type="text" id="node-input-targetNode" style="width: calc(70% - 45px);">
        <button id="node-config-find-source" class="editor-button" style="margin-left: 5px; width: 40px;" title="Find Source Node">
            <i class="fa fa-search"></i>
        </button>
    </div>

    <div class="form-row">
        <label for="node-input-updates"><i class="fa fa-bolt"></i> Trigger</label>
        <select id="node-input-updates" style="width: 70%;">
            <option value="input">Manual (On Input Only)</option>
            <option value="always">Reactive (On Input & Update)</option>
        </select>
    </div>
    
    <div class="form-row">
        <label for="node-input-outputProperty"><i class="fa fa-arrow-right"></i> Output</label>
        <input type="text" id="node-input-outputProperty" placeholder="payload">
        <input type="hidden" id="node-input-outputPropertyType">
        <input type="hidden" id="node-input-dropdownPath">
    </div>

    <div class="form-row">
        <label for="node-input-detail"><i class="fa fa-book"></i> Detail</label>
        <select id="node-input-detail" style="width: 70%;">
            <option value="getValue">Get Simple Value</option>
            <option value="getObject">Get Full Object</option>
        </select>
    </div>

    <div class="form-tips">
        <b>Note:</b> Source path may change without breaking this link. 'Reactive' events do not cause disk reads.
        Setter nodes will always write, on change, to its configured store and 'default' to ensure data stays 'in memory' during operation (avoids disk IO hammering).
        'Manual' reads from 'default' store in memory first. Will fallback to 'persistent'.
    </div>
</script>

<script type="text/javascript">
    RED.nodes.registerType('global-getter', {
        category: "bldgblocks control",
        color: '#3FADB5',
        defaults: {
            name: { value: "" },
            targetNode: { value: "", required: true },
            outputProperty: { value: "payload", required: true },
            outputPropertyType: { value: "msg", required: true },
            dropdownPath: { value: "", required: false },
            updates: { value: "always", required: true },
            detail: {value: "getObject", required: true }
        },
        inputs: 1,
        outputs: 1,
        icon: "font-awesome/fa-align-left",
        label: function() {
            if (this.targetNode) {
                const target = RED.nodes.node(this.targetNode);
                if (target) {
                    let lbl = target.name || target.path;
                    if(lbl && lbl.startsWith("#") && lbl.includes(":")) {
                        lbl = lbl.substring(lbl.indexOf(":") + 1);
                    }
                    return "get: " + lbl;
                }
            }
            return this.name || "global get";
        },
        paletteLabel: "global get",
        oneditprepare: function() {
            const node = this;
            
            let candidateNodes = [];
            RED.nodes.eachNode(function(n) {
                if (n.type === 'global-setter') {
                    let displayPath = n.path || "No Path";
                    if (displayPath.startsWith("#") && displayPath.includes(":")) {
                        displayPath = displayPath.substring(displayPath.indexOf(":") + 1);
                    }
                    
                    candidateNodes.push({
                        value: n.id,
                        label: displayPath + (n.name ? ` (${n.name})` : ""),
                        path: displayPath
                    });
                }
            });

            candidateNodes.sort((a, b) => a.label.localeCompare(b.label));

            $("#node-input-targetNode").typedInput({
                types: [{ value: "target", options: candidateNodes }]
            });
            
            $("#node-input-outputProperty").typedInput({
                default: "msg",
                types: ["msg", "flow",
                    {
                        value: "dropdown",
                        options: [
                            { value: "sourceToFlow", label: "Source To Flow"}
                        ]
                    }],
                typeField: "#node-input-outputPropertyType"
            }).typedInput("type", node.outputPropertyType || "msg").typedInput("value", node.outputProperty);

            function updateOutputValue() {
                const currentType = $("#node-input-outputProperty").typedInput("type");
                
                if (currentType === "dropdown" && node.outputProperty === "sourceToFlow") {
                    const selectedSourceId = $("#node-input-targetNode").val();
                    const selectedOption = candidateNodes.find(opt => opt.value === selectedSourceId);
                    
                    if (selectedOption && selectedOption.path) {
                        $("#node-input-dropdownPath").val(selectedOption.path);
                    }
                }
            }

            $("#node-input-targetNode").on("change", updateOutputValue);
            $("#node-input-outputProperty").on("change", updateOutputValue);

            $("#node-config-find-source").on("click", function() {
                const selectedId = $("#node-input-targetNode").val();
                if (selectedId) { RED.view.reveal(selectedId); } 
                else { RED.notify("Please select a source node first.", "warning"); }
            });
        }
    });
</script>

<!-- Help Section -->
<script type="text/markdown" data-help-name="global-setter">
Manage a global variable in a repeatable way.

### Inputs 
Retreived object will overwrite msg.

### Outputs
: payload (object) : The stored object with values and metadata.

### Details
Global variables are meant to be retrieved in other places, this necessarily means managing the same string in multiple places. 

This node allows you to get a global variable anywhere from one source, while supporting rename and deletion.

The source can be found using the search button. The payload property can be specified and can be set to only the value for chaining.

Reactive updates means every time the source is updated those nodes will receive the new value via event.

### Status
- Green (dot): Configuration update
- Blue (dot): State changed
- Blue (ring): State unchanged
- Red (ring): Error
- Yellow (ring): Warning

### References
- [Node-RED Documentation](https://nodered.org/docs/)  
- [GitHub Repository](https://github.com/BldgBlocks/node-red-contrib-buildingblocks-control.git)
</script>


