<script type="text/html" data-template-name="global-getter">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <div class="form-row">
        <label for="node-input-targetNode"><i class="fa fa-crosshairs"></i> Source</label>
        <input type="text" id="node-input-targetNode" style="width: calc(70% - 45px);">
        <button id="node-config-find-source" class="editor-button" style="margin-left: 5px; width: 40px;" title="Find Source Node">
            <i class="fa fa-search"></i>
        </button>
    </div>

    <!-- NEW: Trigger Mode Selection -->
    <div class="form-row">
        <label for="node-input-updates"><i class="fa fa-bolt"></i> Trigger</label>
        <select id="node-input-updates" style="width: 70%;">
            <option value="input">Manual (On Input Only)</option>
            <option value="always">Reactive (On Input & Update)</option>
        </select>
    </div>
    
    <div class="form-row">
        <label for="node-input-outputProperty"><i class="fa fa-arrow-right"></i> Output</label>
        <input type="text" id="node-input-outputProperty" placeholder="payload" style="width:70%;">
    </div>

    <div class="form-tips">
        <b>Note:</b> Targeting by Node ID allows the source path to change without breaking this link.
    </div>
</script>

<script type="text/javascript">
    RED.nodes.registerType('global-getter', {
        category: 'control',
        color: '#3FADB5',
        defaults: {
            name: { value: "" },
            targetNode: { value: "", required: true },
            outputProperty: { value: "payload", required: true },
            updates: { value: "always", required: true }
        },
        inputs: 1,
        outputs: 1,
        icon: "font-awesome/fa-align-left",
        label: function() {
            if (this.targetNode) {
                const target = RED.nodes.node(this.targetNode);
                if (target) {
                    let lbl = target.path || target.name;
                    if(lbl && lbl.startsWith("#") && lbl.includes(":")) {
                        lbl = lbl.substring(lbl.indexOf(":") + 1);
                    }
                    return "get: " + lbl;
                }
            }
            return this.name || "global get";
        },
        paletteLabel: "global get",
        oneditprepare: function() {
            const node = this;
            
            let candidateNodes = [];
            RED.nodes.eachNode(function(n) {
                if (n.type === 'global-setter') {
                    let displayPath = n.path || "No Path";
                    if (displayPath.startsWith("#") && displayPath.includes(":")) {
                        displayPath = displayPath.substring(displayPath.indexOf(":") + 1);
                    }
                    candidateNodes.push({
                        value: n.id,
                        label: displayPath + (n.name ? ` (${n.name})` : "")
                    });
                }
            });

            candidateNodes.sort((a, b) => a.label.localeCompare(b.label));

            $("#node-input-targetNode").typedInput({
                types: [{ value: "target", options: candidateNodes }]
            });

            $("#node-input-outputProperty").typedInput({ types: ['msg'] });

            $("#node-config-find-source").on("click", function() {
                const selectedId = $("#node-input-targetNode").val();
                if (selectedId) { RED.view.reveal(selectedId); } 
                else { RED.notify("Please select a source node first.", "warning"); }
            });
        }
    });
</script>
